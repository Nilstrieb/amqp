#![allow(dead_code)]
// This file has been generated by `xtask/src/codegen`. Do not edit it manually.

pub mod parse {
    use crate::error::TransError;
    use crate::methods::parse_helper::*;
    use amqp_core::methods::*;
    use nom::{branch::alt, bytes::complete::tag};
    use once_cell::sync::Lazy;
    use regex::Regex;

    pub type IResult<'a, T> = nom::IResult<&'a [u8], T, TransError>;

    pub fn parse_method(input: &[u8]) -> Result<(&[u8], Method), nom::Err<TransError>> {
        alt((connection, channel, exchange, queue, basic, tx))(input)
    }
    fn domain_class_id(input: &[u8]) -> IResult<'_, ClassId> {
        short(input)
    }
    fn domain_consumer_tag(input: &[u8]) -> IResult<'_, ConsumerTag> {
        shortstr(input)
    }
    fn domain_delivery_tag(input: &[u8]) -> IResult<'_, DeliveryTag> {
        longlong(input)
    }
    fn domain_exchange_name(input: &[u8]) -> IResult<'_, ExchangeName> {
        let (input, result) = shortstr(input)?;
        if result.len() > 127 {
            fail!("value is shorter than 127 for field result")
        }
        static REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r"^[a-zA-Z0-9-_.:]*$").unwrap());
        if !REGEX.is_match(&result) {
            fail!(r"regex `^[a-zA-Z0-9-_.:]*$` did not match value for field result")
        }
        Ok((input, result))
    }
    fn domain_method_id(input: &[u8]) -> IResult<'_, MethodId> {
        short(input)
    }
    fn domain_path(input: &[u8]) -> IResult<'_, Path> {
        let (input, result) = shortstr(input)?;
        if result.is_empty() {
            fail!("string was null for field result")
        }
        if result.len() > 127 {
            fail!("value is shorter than 127 for field result")
        }
        Ok((input, result))
    }
    fn domain_peer_properties(input: &[u8]) -> IResult<'_, PeerProperties> {
        table(input)
    }
    fn domain_queue_name(input: &[u8]) -> IResult<'_, QueueName> {
        let (input, result) = shortstr(input)?;
        if result.len() > 127 {
            fail!("value is shorter than 127 for field result")
        }
        static REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r"^[a-zA-Z0-9-_.:]*$").unwrap());
        if !REGEX.is_match(&result) {
            fail!(r"regex `^[a-zA-Z0-9-_.:]*$` did not match value for field result")
        }
        Ok((input, result))
    }
    fn domain_message_count(input: &[u8]) -> IResult<'_, MessageCount> {
        long(input)
    }
    fn domain_reply_code(input: &[u8]) -> IResult<'_, ReplyCode> {
        let (input, result) = short(input)?;
        Ok((input, result))
    }
    fn domain_reply_text(input: &[u8]) -> IResult<'_, ReplyText> {
        let (input, result) = shortstr(input)?;
        if result.is_empty() {
            fail!("string was null for field result")
        }
        Ok((input, result))
    }
    fn domain_octet(input: &[u8]) -> IResult<'_, Octet> {
        octet(input)
    }
    fn domain_short(input: &[u8]) -> IResult<'_, Short> {
        short(input)
    }
    fn domain_long(input: &[u8]) -> IResult<'_, Long> {
        long(input)
    }
    fn domain_longlong(input: &[u8]) -> IResult<'_, Longlong> {
        longlong(input)
    }
    fn domain_shortstr(input: &[u8]) -> IResult<'_, Shortstr> {
        shortstr(input)
    }
    fn domain_longstr(input: &[u8]) -> IResult<'_, Longstr> {
        longstr(input)
    }
    fn domain_timestamp(input: &[u8]) -> IResult<'_, Timestamp> {
        timestamp(input)
    }
    fn domain_table(input: &[u8]) -> IResult<'_, Table> {
        table(input)
    }
    fn connection(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(10_u16.to_be_bytes())(input)?;
        alt((
            connection_start,
            connection_start_ok,
            connection_secure,
            connection_secure_ok,
            connection_tune,
            connection_tune_ok,
            connection_open,
            connection_open_ok,
            connection_close,
            connection_close_ok,
        ))(input)
        .map_err(fail_err("class connection"))
    }
    fn connection_start(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(10_u16.to_be_bytes())(input)?;
        let (input, version_major) =
            domain_octet(input).map_err(fail_err("field version-major in method start"))?;
        let (input, version_minor) =
            domain_octet(input).map_err(fail_err("field version-minor in method start"))?;
        let (input, server_properties) = domain_peer_properties(input)
            .map_err(fail_err("field server-properties in method start"))?;
        let (input, mechanisms) =
            domain_longstr(input).map_err(fail_err("field mechanisms in method start"))?;
        if mechanisms.is_empty() {
            fail!("string was null for field mechanisms")
        }
        let (input, locales) =
            domain_longstr(input).map_err(fail_err("field locales in method start"))?;
        if locales.is_empty() {
            fail!("string was null for field locales")
        }
        Ok((
            input,
            Method::ConnectionStart(ConnectionStart {
                version_major,
                version_minor,
                server_properties,
                mechanisms,
                locales,
            }),
        ))
    }
    fn connection_start_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(11_u16.to_be_bytes())(input)?;
        let (input, client_properties) = domain_peer_properties(input)
            .map_err(fail_err("field client-properties in method start-ok"))?;
        let (input, mechanism) =
            domain_shortstr(input).map_err(fail_err("field mechanism in method start-ok"))?;
        if mechanism.is_empty() {
            fail!("string was null for field mechanism")
        }
        let (input, response) =
            domain_longstr(input).map_err(fail_err("field response in method start-ok"))?;
        if response.is_empty() {
            fail!("string was null for field response")
        }
        let (input, locale) =
            domain_shortstr(input).map_err(fail_err("field locale in method start-ok"))?;
        if locale.is_empty() {
            fail!("string was null for field locale")
        }
        Ok((
            input,
            Method::ConnectionStartOk(ConnectionStartOk {
                client_properties,
                mechanism,
                response,
                locale,
            }),
        ))
    }
    fn connection_secure(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(20_u16.to_be_bytes())(input)?;
        let (input, challenge) =
            domain_longstr(input).map_err(fail_err("field challenge in method secure"))?;
        Ok((
            input,
            Method::ConnectionSecure(ConnectionSecure { challenge }),
        ))
    }
    fn connection_secure_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(21_u16.to_be_bytes())(input)?;
        let (input, response) =
            domain_longstr(input).map_err(fail_err("field response in method secure-ok"))?;
        if response.is_empty() {
            fail!("string was null for field response")
        }
        Ok((
            input,
            Method::ConnectionSecureOk(ConnectionSecureOk { response }),
        ))
    }
    fn connection_tune(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(30_u16.to_be_bytes())(input)?;
        let (input, channel_max) =
            domain_short(input).map_err(fail_err("field channel-max in method tune"))?;
        let (input, frame_max) =
            domain_long(input).map_err(fail_err("field frame-max in method tune"))?;
        let (input, heartbeat) =
            domain_short(input).map_err(fail_err("field heartbeat in method tune"))?;
        Ok((
            input,
            Method::ConnectionTune(ConnectionTune {
                channel_max,
                frame_max,
                heartbeat,
            }),
        ))
    }
    fn connection_tune_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(31_u16.to_be_bytes())(input)?;
        let (input, channel_max) =
            domain_short(input).map_err(fail_err("field channel-max in method tune-ok"))?;
        let (input, frame_max) =
            domain_long(input).map_err(fail_err("field frame-max in method tune-ok"))?;
        let (input, heartbeat) =
            domain_short(input).map_err(fail_err("field heartbeat in method tune-ok"))?;
        Ok((
            input,
            Method::ConnectionTuneOk(ConnectionTuneOk {
                channel_max,
                frame_max,
                heartbeat,
            }),
        ))
    }
    fn connection_open(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(40_u16.to_be_bytes())(input)?;
        let (input, virtual_host) =
            domain_path(input).map_err(fail_err("field virtual-host in method open"))?;
        let (input, reserved_1) =
            domain_shortstr(input).map_err(fail_err("field reserved-1 in method open"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field reserved-2 in method open"))?;
        let reserved_2 = bits[0];
        Ok((
            input,
            Method::ConnectionOpen(ConnectionOpen {
                virtual_host,
                reserved_1,
                reserved_2,
            }),
        ))
    }
    fn connection_open_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(41_u16.to_be_bytes())(input)?;
        let (input, reserved_1) =
            domain_shortstr(input).map_err(fail_err("field reserved-1 in method open-ok"))?;
        Ok((
            input,
            Method::ConnectionOpenOk(ConnectionOpenOk { reserved_1 }),
        ))
    }
    fn connection_close(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(50_u16.to_be_bytes())(input)?;
        let (input, reply_code) =
            domain_reply_code(input).map_err(fail_err("field reply-code in method close"))?;
        let (input, reply_text) =
            domain_reply_text(input).map_err(fail_err("field reply-text in method close"))?;
        let (input, class_id) =
            domain_class_id(input).map_err(fail_err("field class-id in method close"))?;
        let (input, method_id) =
            domain_method_id(input).map_err(fail_err("field method-id in method close"))?;
        Ok((
            input,
            Method::ConnectionClose(ConnectionClose {
                reply_code,
                reply_text,
                class_id,
                method_id,
            }),
        ))
    }
    fn connection_close_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(51_u16.to_be_bytes())(input)?;
        Ok((input, Method::ConnectionCloseOk(ConnectionCloseOk {})))
    }
    fn channel(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(20_u16.to_be_bytes())(input)?;
        alt((
            channel_open,
            channel_open_ok,
            channel_flow,
            channel_flow_ok,
            channel_close,
            channel_close_ok,
        ))(input)
        .map_err(fail_err("class channel"))
    }
    fn channel_open(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(10_u16.to_be_bytes())(input)?;
        let (input, reserved_1) =
            domain_shortstr(input).map_err(fail_err("field reserved-1 in method open"))?;
        Ok((input, Method::ChannelOpen(ChannelOpen { reserved_1 })))
    }
    fn channel_open_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(11_u16.to_be_bytes())(input)?;
        let (input, reserved_1) =
            domain_longstr(input).map_err(fail_err("field reserved-1 in method open-ok"))?;
        Ok((input, Method::ChannelOpenOk(ChannelOpenOk { reserved_1 })))
    }
    fn channel_flow(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(20_u16.to_be_bytes())(input)?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field active in method flow"))?;
        let active = bits[0];
        Ok((input, Method::ChannelFlow(ChannelFlow { active })))
    }
    fn channel_flow_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(21_u16.to_be_bytes())(input)?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field active in method flow-ok"))?;
        let active = bits[0];
        Ok((input, Method::ChannelFlowOk(ChannelFlowOk { active })))
    }
    fn channel_close(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(40_u16.to_be_bytes())(input)?;
        let (input, reply_code) =
            domain_reply_code(input).map_err(fail_err("field reply-code in method close"))?;
        let (input, reply_text) =
            domain_reply_text(input).map_err(fail_err("field reply-text in method close"))?;
        let (input, class_id) =
            domain_class_id(input).map_err(fail_err("field class-id in method close"))?;
        let (input, method_id) =
            domain_method_id(input).map_err(fail_err("field method-id in method close"))?;
        Ok((
            input,
            Method::ChannelClose(ChannelClose {
                reply_code,
                reply_text,
                class_id,
                method_id,
            }),
        ))
    }
    fn channel_close_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(41_u16.to_be_bytes())(input)?;
        Ok((input, Method::ChannelCloseOk(ChannelCloseOk {})))
    }
    fn exchange(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(40_u16.to_be_bytes())(input)?;
        alt((
            exchange_declare,
            exchange_declare_ok,
            exchange_delete,
            exchange_delete_ok,
        ))(input)
        .map_err(fail_err("class exchange"))
    }
    fn exchange_declare(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(10_u16.to_be_bytes())(input)?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method declare"))?;
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method declare"))?;
        if exchange.is_empty() {
            fail!("string was null for field exchange")
        }
        let (input, r#type) =
            domain_shortstr(input).map_err(fail_err("field type in method declare"))?;
        let (input, bits) = bit(input, 5).map_err(fail_err("field passive in method declare"))?;
        let passive = bits[0];
        let durable = bits[1];
        let reserved_2 = bits[2];
        let reserved_3 = bits[3];
        let no_wait = bits[4];
        let (input, arguments) =
            domain_table(input).map_err(fail_err("field arguments in method declare"))?;
        Ok((
            input,
            Method::ExchangeDeclare(ExchangeDeclare {
                reserved_1,
                exchange,
                r#type,
                passive,
                durable,
                reserved_2,
                reserved_3,
                no_wait,
                arguments,
            }),
        ))
    }
    fn exchange_declare_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(11_u16.to_be_bytes())(input)?;
        Ok((input, Method::ExchangeDeclareOk(ExchangeDeclareOk {})))
    }
    fn exchange_delete(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(20_u16.to_be_bytes())(input)?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method delete"))?;
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method delete"))?;
        if exchange.is_empty() {
            fail!("string was null for field exchange")
        }
        let (input, bits) = bit(input, 2).map_err(fail_err("field if-unused in method delete"))?;
        let if_unused = bits[0];
        let no_wait = bits[1];
        Ok((
            input,
            Method::ExchangeDelete(ExchangeDelete {
                reserved_1,
                exchange,
                if_unused,
                no_wait,
            }),
        ))
    }
    fn exchange_delete_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(21_u16.to_be_bytes())(input)?;
        Ok((input, Method::ExchangeDeleteOk(ExchangeDeleteOk {})))
    }
    fn queue(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(50_u16.to_be_bytes())(input)?;
        alt((
            queue_declare,
            queue_declare_ok,
            queue_bind,
            queue_bind_ok,
            queue_unbind,
            queue_unbind_ok,
            queue_purge,
            queue_purge_ok,
            queue_delete,
            queue_delete_ok,
        ))(input)
        .map_err(fail_err("class queue"))
    }
    fn queue_declare(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(10_u16.to_be_bytes())(input)?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method declare"))?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method declare"))?;
        let (input, bits) = bit(input, 5).map_err(fail_err("field passive in method declare"))?;
        let passive = bits[0];
        let durable = bits[1];
        let exclusive = bits[2];
        let auto_delete = bits[3];
        let no_wait = bits[4];
        let (input, arguments) =
            domain_table(input).map_err(fail_err("field arguments in method declare"))?;
        Ok((
            input,
            Method::QueueDeclare(QueueDeclare {
                reserved_1,
                queue,
                passive,
                durable,
                exclusive,
                auto_delete,
                no_wait,
                arguments,
            }),
        ))
    }
    fn queue_declare_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(11_u16.to_be_bytes())(input)?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method declare-ok"))?;
        if queue.is_empty() {
            fail!("string was null for field queue")
        }
        let (input, message_count) = domain_message_count(input)
            .map_err(fail_err("field message-count in method declare-ok"))?;
        let (input, consumer_count) =
            domain_long(input).map_err(fail_err("field consumer-count in method declare-ok"))?;
        Ok((
            input,
            Method::QueueDeclareOk(QueueDeclareOk {
                queue,
                message_count,
                consumer_count,
            }),
        ))
    }
    fn queue_bind(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(20_u16.to_be_bytes())(input)?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method bind"))?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method bind"))?;
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method bind"))?;
        let (input, routing_key) =
            domain_shortstr(input).map_err(fail_err("field routing-key in method bind"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field no-wait in method bind"))?;
        let no_wait = bits[0];
        let (input, arguments) =
            domain_table(input).map_err(fail_err("field arguments in method bind"))?;
        Ok((
            input,
            Method::QueueBind(QueueBind {
                reserved_1,
                queue,
                exchange,
                routing_key,
                no_wait,
                arguments,
            }),
        ))
    }
    fn queue_bind_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(21_u16.to_be_bytes())(input)?;
        Ok((input, Method::QueueBindOk(QueueBindOk {})))
    }
    fn queue_unbind(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(50_u16.to_be_bytes())(input)?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method unbind"))?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method unbind"))?;
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method unbind"))?;
        let (input, routing_key) =
            domain_shortstr(input).map_err(fail_err("field routing-key in method unbind"))?;
        let (input, arguments) =
            domain_table(input).map_err(fail_err("field arguments in method unbind"))?;
        Ok((
            input,
            Method::QueueUnbind(QueueUnbind {
                reserved_1,
                queue,
                exchange,
                routing_key,
                arguments,
            }),
        ))
    }
    fn queue_unbind_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(51_u16.to_be_bytes())(input)?;
        Ok((input, Method::QueueUnbindOk(QueueUnbindOk {})))
    }
    fn queue_purge(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(30_u16.to_be_bytes())(input)?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method purge"))?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method purge"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field no-wait in method purge"))?;
        let no_wait = bits[0];
        Ok((
            input,
            Method::QueuePurge(QueuePurge {
                reserved_1,
                queue,
                no_wait,
            }),
        ))
    }
    fn queue_purge_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(31_u16.to_be_bytes())(input)?;
        let (input, message_count) = domain_message_count(input)
            .map_err(fail_err("field message-count in method purge-ok"))?;
        Ok((input, Method::QueuePurgeOk(QueuePurgeOk { message_count })))
    }
    fn queue_delete(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(40_u16.to_be_bytes())(input)?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method delete"))?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method delete"))?;
        let (input, bits) = bit(input, 3).map_err(fail_err("field if-unused in method delete"))?;
        let if_unused = bits[0];
        let if_empty = bits[1];
        let no_wait = bits[2];
        Ok((
            input,
            Method::QueueDelete(QueueDelete {
                reserved_1,
                queue,
                if_unused,
                if_empty,
                no_wait,
            }),
        ))
    }
    fn queue_delete_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(41_u16.to_be_bytes())(input)?;
        let (input, message_count) = domain_message_count(input)
            .map_err(fail_err("field message-count in method delete-ok"))?;
        Ok((
            input,
            Method::QueueDeleteOk(QueueDeleteOk { message_count }),
        ))
    }
    fn basic(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(60_u16.to_be_bytes())(input)?;
        alt((
            basic_qos,
            basic_qos_ok,
            basic_consume,
            basic_consume_ok,
            basic_cancel,
            basic_cancel_ok,
            basic_publish,
            basic_return,
            basic_deliver,
            basic_get,
            basic_get_ok,
            basic_get_empty,
            basic_ack,
            basic_reject,
            basic_recover_async,
            basic_recover,
            basic_recover_ok,
        ))(input)
        .map_err(fail_err("class basic"))
    }
    fn basic_qos(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(10_u16.to_be_bytes())(input)?;
        let (input, prefetch_size) =
            domain_long(input).map_err(fail_err("field prefetch-size in method qos"))?;
        let (input, prefetch_count) =
            domain_short(input).map_err(fail_err("field prefetch-count in method qos"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field global in method qos"))?;
        let global = bits[0];
        Ok((
            input,
            Method::BasicQos(BasicQos {
                prefetch_size,
                prefetch_count,
                global,
            }),
        ))
    }
    fn basic_qos_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(11_u16.to_be_bytes())(input)?;
        Ok((input, Method::BasicQosOk(BasicQosOk {})))
    }
    fn basic_consume(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(20_u16.to_be_bytes())(input)?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method consume"))?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method consume"))?;
        let (input, consumer_tag) =
            domain_consumer_tag(input).map_err(fail_err("field consumer-tag in method consume"))?;
        let (input, bits) = bit(input, 4).map_err(fail_err("field no-local in method consume"))?;
        let no_local = bits[0];
        let no_ack = bits[1];
        let exclusive = bits[2];
        let no_wait = bits[3];
        let (input, arguments) =
            domain_table(input).map_err(fail_err("field arguments in method consume"))?;
        Ok((
            input,
            Method::BasicConsume(BasicConsume {
                reserved_1,
                queue,
                consumer_tag,
                no_local,
                no_ack,
                exclusive,
                no_wait,
                arguments,
            }),
        ))
    }
    fn basic_consume_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(21_u16.to_be_bytes())(input)?;
        let (input, consumer_tag) = domain_consumer_tag(input)
            .map_err(fail_err("field consumer-tag in method consume-ok"))?;
        Ok((
            input,
            Method::BasicConsumeOk(BasicConsumeOk { consumer_tag }),
        ))
    }
    fn basic_cancel(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(30_u16.to_be_bytes())(input)?;
        let (input, consumer_tag) =
            domain_consumer_tag(input).map_err(fail_err("field consumer-tag in method cancel"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field no-wait in method cancel"))?;
        let no_wait = bits[0];
        Ok((
            input,
            Method::BasicCancel(BasicCancel {
                consumer_tag,
                no_wait,
            }),
        ))
    }
    fn basic_cancel_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(31_u16.to_be_bytes())(input)?;
        let (input, consumer_tag) = domain_consumer_tag(input)
            .map_err(fail_err("field consumer-tag in method cancel-ok"))?;
        Ok((input, Method::BasicCancelOk(BasicCancelOk { consumer_tag })))
    }
    fn basic_publish(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(40_u16.to_be_bytes())(input)?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method publish"))?;
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method publish"))?;
        let (input, routing_key) =
            domain_shortstr(input).map_err(fail_err("field routing-key in method publish"))?;
        let (input, bits) = bit(input, 2).map_err(fail_err("field mandatory in method publish"))?;
        let mandatory = bits[0];
        let immediate = bits[1];
        Ok((
            input,
            Method::BasicPublish(BasicPublish {
                reserved_1,
                exchange,
                routing_key,
                mandatory,
                immediate,
            }),
        ))
    }
    fn basic_return(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(50_u16.to_be_bytes())(input)?;
        let (input, reply_code) =
            domain_reply_code(input).map_err(fail_err("field reply-code in method return"))?;
        let (input, reply_text) =
            domain_reply_text(input).map_err(fail_err("field reply-text in method return"))?;
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method return"))?;
        let (input, routing_key) =
            domain_shortstr(input).map_err(fail_err("field routing-key in method return"))?;
        Ok((
            input,
            Method::BasicReturn(BasicReturn {
                reply_code,
                reply_text,
                exchange,
                routing_key,
            }),
        ))
    }
    fn basic_deliver(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(60_u16.to_be_bytes())(input)?;
        let (input, consumer_tag) =
            domain_consumer_tag(input).map_err(fail_err("field consumer-tag in method deliver"))?;
        let (input, delivery_tag) =
            domain_delivery_tag(input).map_err(fail_err("field delivery-tag in method deliver"))?;
        let (input, bits) =
            bit(input, 1).map_err(fail_err("field redelivered in method deliver"))?;
        let redelivered = bits[0];
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method deliver"))?;
        let (input, routing_key) =
            domain_shortstr(input).map_err(fail_err("field routing-key in method deliver"))?;
        Ok((
            input,
            Method::BasicDeliver(BasicDeliver {
                consumer_tag,
                delivery_tag,
                redelivered,
                exchange,
                routing_key,
            }),
        ))
    }
    fn basic_get(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(70_u16.to_be_bytes())(input)?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method get"))?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method get"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field no-ack in method get"))?;
        let no_ack = bits[0];
        Ok((
            input,
            Method::BasicGet(BasicGet {
                reserved_1,
                queue,
                no_ack,
            }),
        ))
    }
    fn basic_get_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(71_u16.to_be_bytes())(input)?;
        let (input, delivery_tag) =
            domain_delivery_tag(input).map_err(fail_err("field delivery-tag in method get-ok"))?;
        let (input, bits) =
            bit(input, 1).map_err(fail_err("field redelivered in method get-ok"))?;
        let redelivered = bits[0];
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method get-ok"))?;
        let (input, routing_key) =
            domain_shortstr(input).map_err(fail_err("field routing-key in method get-ok"))?;
        let (input, message_count) = domain_message_count(input)
            .map_err(fail_err("field message-count in method get-ok"))?;
        Ok((
            input,
            Method::BasicGetOk(BasicGetOk {
                delivery_tag,
                redelivered,
                exchange,
                routing_key,
                message_count,
            }),
        ))
    }
    fn basic_get_empty(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(72_u16.to_be_bytes())(input)?;
        let (input, reserved_1) =
            domain_shortstr(input).map_err(fail_err("field reserved-1 in method get-empty"))?;
        Ok((input, Method::BasicGetEmpty(BasicGetEmpty { reserved_1 })))
    }
    fn basic_ack(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(80_u16.to_be_bytes())(input)?;
        let (input, delivery_tag) =
            domain_delivery_tag(input).map_err(fail_err("field delivery-tag in method ack"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field multiple in method ack"))?;
        let multiple = bits[0];
        Ok((
            input,
            Method::BasicAck(BasicAck {
                delivery_tag,
                multiple,
            }),
        ))
    }
    fn basic_reject(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(90_u16.to_be_bytes())(input)?;
        let (input, delivery_tag) =
            domain_delivery_tag(input).map_err(fail_err("field delivery-tag in method reject"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field requeue in method reject"))?;
        let requeue = bits[0];
        Ok((
            input,
            Method::BasicReject(BasicReject {
                delivery_tag,
                requeue,
            }),
        ))
    }
    fn basic_recover_async(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(100_u16.to_be_bytes())(input)?;
        let (input, bits) =
            bit(input, 1).map_err(fail_err("field requeue in method recover-async"))?;
        let requeue = bits[0];
        Ok((
            input,
            Method::BasicRecoverAsync(BasicRecoverAsync { requeue }),
        ))
    }
    fn basic_recover(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(110_u16.to_be_bytes())(input)?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field requeue in method recover"))?;
        let requeue = bits[0];
        Ok((input, Method::BasicRecover(BasicRecover { requeue })))
    }
    fn basic_recover_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(111_u16.to_be_bytes())(input)?;
        Ok((input, Method::BasicRecoverOk(BasicRecoverOk {})))
    }
    fn tx(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(90_u16.to_be_bytes())(input)?;
        alt((
            tx_select,
            tx_select_ok,
            tx_commit,
            tx_commit_ok,
            tx_rollback,
            tx_rollback_ok,
        ))(input)
        .map_err(fail_err("class tx"))
    }
    fn tx_select(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(10_u16.to_be_bytes())(input)?;
        Ok((input, Method::TxSelect(TxSelect {})))
    }
    fn tx_select_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(11_u16.to_be_bytes())(input)?;
        Ok((input, Method::TxSelectOk(TxSelectOk {})))
    }
    fn tx_commit(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(20_u16.to_be_bytes())(input)?;
        Ok((input, Method::TxCommit(TxCommit {})))
    }
    fn tx_commit_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(21_u16.to_be_bytes())(input)?;
        Ok((input, Method::TxCommitOk(TxCommitOk {})))
    }
    fn tx_rollback(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(30_u16.to_be_bytes())(input)?;
        Ok((input, Method::TxRollback(TxRollback {})))
    }
    fn tx_rollback_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(31_u16.to_be_bytes())(input)?;
        Ok((input, Method::TxRollbackOk(TxRollbackOk {})))
    }
}
pub mod write {
    use crate::error::TransError;
    use crate::methods::write_helper::*;
    use amqp_core::methods::*;
    use std::io::Write;

    pub fn write_method<W: Write>(method: Method, mut writer: W) -> Result<(), TransError> {
        match method {
            Method::ConnectionStart(ConnectionStart {
                version_major,
                version_minor,
                server_properties,
                mechanisms,
                locales,
            }) => {
                writer.write_all(&[0, 10, 0, 10])?;
                octet(version_major, &mut writer)?;
                octet(version_minor, &mut writer)?;
                table(server_properties, &mut writer)?;
                longstr(mechanisms, &mut writer)?;
                longstr(locales, &mut writer)?;
            }
            Method::ConnectionStartOk(ConnectionStartOk {
                client_properties,
                mechanism,
                response,
                locale,
            }) => {
                writer.write_all(&[0, 10, 0, 11])?;
                table(client_properties, &mut writer)?;
                shortstr(mechanism, &mut writer)?;
                longstr(response, &mut writer)?;
                shortstr(locale, &mut writer)?;
            }
            Method::ConnectionSecure(ConnectionSecure { challenge }) => {
                writer.write_all(&[0, 10, 0, 20])?;
                longstr(challenge, &mut writer)?;
            }
            Method::ConnectionSecureOk(ConnectionSecureOk { response }) => {
                writer.write_all(&[0, 10, 0, 21])?;
                longstr(response, &mut writer)?;
            }
            Method::ConnectionTune(ConnectionTune {
                channel_max,
                frame_max,
                heartbeat,
            }) => {
                writer.write_all(&[0, 10, 0, 30])?;
                short(channel_max, &mut writer)?;
                long(frame_max, &mut writer)?;
                short(heartbeat, &mut writer)?;
            }
            Method::ConnectionTuneOk(ConnectionTuneOk {
                channel_max,
                frame_max,
                heartbeat,
            }) => {
                writer.write_all(&[0, 10, 0, 31])?;
                short(channel_max, &mut writer)?;
                long(frame_max, &mut writer)?;
                short(heartbeat, &mut writer)?;
            }
            Method::ConnectionOpen(ConnectionOpen {
                virtual_host,
                reserved_1,
                reserved_2,
            }) => {
                writer.write_all(&[0, 10, 0, 40])?;
                shortstr(virtual_host, &mut writer)?;
                shortstr(reserved_1, &mut writer)?;
                bit(&[reserved_2], &mut writer)?;
            }
            Method::ConnectionOpenOk(ConnectionOpenOk { reserved_1 }) => {
                writer.write_all(&[0, 10, 0, 41])?;
                shortstr(reserved_1, &mut writer)?;
            }
            Method::ConnectionClose(ConnectionClose {
                reply_code,
                reply_text,
                class_id,
                method_id,
            }) => {
                writer.write_all(&[0, 10, 0, 50])?;
                short(reply_code, &mut writer)?;
                shortstr(reply_text, &mut writer)?;
                short(class_id, &mut writer)?;
                short(method_id, &mut writer)?;
            }
            Method::ConnectionCloseOk(ConnectionCloseOk {}) => {
                writer.write_all(&[0, 10, 0, 51])?;
            }
            Method::ChannelOpen(ChannelOpen { reserved_1 }) => {
                writer.write_all(&[0, 20, 0, 10])?;
                shortstr(reserved_1, &mut writer)?;
            }
            Method::ChannelOpenOk(ChannelOpenOk { reserved_1 }) => {
                writer.write_all(&[0, 20, 0, 11])?;
                longstr(reserved_1, &mut writer)?;
            }
            Method::ChannelFlow(ChannelFlow { active }) => {
                writer.write_all(&[0, 20, 0, 20])?;
                bit(&[active], &mut writer)?;
            }
            Method::ChannelFlowOk(ChannelFlowOk { active }) => {
                writer.write_all(&[0, 20, 0, 21])?;
                bit(&[active], &mut writer)?;
            }
            Method::ChannelClose(ChannelClose {
                reply_code,
                reply_text,
                class_id,
                method_id,
            }) => {
                writer.write_all(&[0, 20, 0, 40])?;
                short(reply_code, &mut writer)?;
                shortstr(reply_text, &mut writer)?;
                short(class_id, &mut writer)?;
                short(method_id, &mut writer)?;
            }
            Method::ChannelCloseOk(ChannelCloseOk {}) => {
                writer.write_all(&[0, 20, 0, 41])?;
            }
            Method::ExchangeDeclare(ExchangeDeclare {
                reserved_1,
                exchange,
                r#type,
                passive,
                durable,
                reserved_2,
                reserved_3,
                no_wait,
                arguments,
            }) => {
                writer.write_all(&[0, 40, 0, 10])?;
                short(reserved_1, &mut writer)?;
                shortstr(exchange, &mut writer)?;
                shortstr(r#type, &mut writer)?;
                bit(
                    &[passive, durable, reserved_2, reserved_3, no_wait],
                    &mut writer,
                )?;
                table(arguments, &mut writer)?;
            }
            Method::ExchangeDeclareOk(ExchangeDeclareOk {}) => {
                writer.write_all(&[0, 40, 0, 11])?;
            }
            Method::ExchangeDelete(ExchangeDelete {
                reserved_1,
                exchange,
                if_unused,
                no_wait,
            }) => {
                writer.write_all(&[0, 40, 0, 20])?;
                short(reserved_1, &mut writer)?;
                shortstr(exchange, &mut writer)?;
                bit(&[if_unused, no_wait], &mut writer)?;
            }
            Method::ExchangeDeleteOk(ExchangeDeleteOk {}) => {
                writer.write_all(&[0, 40, 0, 21])?;
            }
            Method::QueueDeclare(QueueDeclare {
                reserved_1,
                queue,
                passive,
                durable,
                exclusive,
                auto_delete,
                no_wait,
                arguments,
            }) => {
                writer.write_all(&[0, 50, 0, 10])?;
                short(reserved_1, &mut writer)?;
                shortstr(queue, &mut writer)?;
                bit(
                    &[passive, durable, exclusive, auto_delete, no_wait],
                    &mut writer,
                )?;
                table(arguments, &mut writer)?;
            }
            Method::QueueDeclareOk(QueueDeclareOk {
                queue,
                message_count,
                consumer_count,
            }) => {
                writer.write_all(&[0, 50, 0, 11])?;
                shortstr(queue, &mut writer)?;
                long(message_count, &mut writer)?;
                long(consumer_count, &mut writer)?;
            }
            Method::QueueBind(QueueBind {
                reserved_1,
                queue,
                exchange,
                routing_key,
                no_wait,
                arguments,
            }) => {
                writer.write_all(&[0, 50, 0, 20])?;
                short(reserved_1, &mut writer)?;
                shortstr(queue, &mut writer)?;
                shortstr(exchange, &mut writer)?;
                shortstr(routing_key, &mut writer)?;
                bit(&[no_wait], &mut writer)?;
                table(arguments, &mut writer)?;
            }
            Method::QueueBindOk(QueueBindOk {}) => {
                writer.write_all(&[0, 50, 0, 21])?;
            }
            Method::QueueUnbind(QueueUnbind {
                reserved_1,
                queue,
                exchange,
                routing_key,
                arguments,
            }) => {
                writer.write_all(&[0, 50, 0, 50])?;
                short(reserved_1, &mut writer)?;
                shortstr(queue, &mut writer)?;
                shortstr(exchange, &mut writer)?;
                shortstr(routing_key, &mut writer)?;
                table(arguments, &mut writer)?;
            }
            Method::QueueUnbindOk(QueueUnbindOk {}) => {
                writer.write_all(&[0, 50, 0, 51])?;
            }
            Method::QueuePurge(QueuePurge {
                reserved_1,
                queue,
                no_wait,
            }) => {
                writer.write_all(&[0, 50, 0, 30])?;
                short(reserved_1, &mut writer)?;
                shortstr(queue, &mut writer)?;
                bit(&[no_wait], &mut writer)?;
            }
            Method::QueuePurgeOk(QueuePurgeOk { message_count }) => {
                writer.write_all(&[0, 50, 0, 31])?;
                long(message_count, &mut writer)?;
            }
            Method::QueueDelete(QueueDelete {
                reserved_1,
                queue,
                if_unused,
                if_empty,
                no_wait,
            }) => {
                writer.write_all(&[0, 50, 0, 40])?;
                short(reserved_1, &mut writer)?;
                shortstr(queue, &mut writer)?;
                bit(&[if_unused, if_empty, no_wait], &mut writer)?;
            }
            Method::QueueDeleteOk(QueueDeleteOk { message_count }) => {
                writer.write_all(&[0, 50, 0, 41])?;
                long(message_count, &mut writer)?;
            }
            Method::BasicQos(BasicQos {
                prefetch_size,
                prefetch_count,
                global,
            }) => {
                writer.write_all(&[0, 60, 0, 10])?;
                long(prefetch_size, &mut writer)?;
                short(prefetch_count, &mut writer)?;
                bit(&[global], &mut writer)?;
            }
            Method::BasicQosOk(BasicQosOk {}) => {
                writer.write_all(&[0, 60, 0, 11])?;
            }
            Method::BasicConsume(BasicConsume {
                reserved_1,
                queue,
                consumer_tag,
                no_local,
                no_ack,
                exclusive,
                no_wait,
                arguments,
            }) => {
                writer.write_all(&[0, 60, 0, 20])?;
                short(reserved_1, &mut writer)?;
                shortstr(queue, &mut writer)?;
                shortstr(consumer_tag, &mut writer)?;
                bit(&[no_local, no_ack, exclusive, no_wait], &mut writer)?;
                table(arguments, &mut writer)?;
            }
            Method::BasicConsumeOk(BasicConsumeOk { consumer_tag }) => {
                writer.write_all(&[0, 60, 0, 21])?;
                shortstr(consumer_tag, &mut writer)?;
            }
            Method::BasicCancel(BasicCancel {
                consumer_tag,
                no_wait,
            }) => {
                writer.write_all(&[0, 60, 0, 30])?;
                shortstr(consumer_tag, &mut writer)?;
                bit(&[no_wait], &mut writer)?;
            }
            Method::BasicCancelOk(BasicCancelOk { consumer_tag }) => {
                writer.write_all(&[0, 60, 0, 31])?;
                shortstr(consumer_tag, &mut writer)?;
            }
            Method::BasicPublish(BasicPublish {
                reserved_1,
                exchange,
                routing_key,
                mandatory,
                immediate,
            }) => {
                writer.write_all(&[0, 60, 0, 40])?;
                short(reserved_1, &mut writer)?;
                shortstr(exchange, &mut writer)?;
                shortstr(routing_key, &mut writer)?;
                bit(&[mandatory, immediate], &mut writer)?;
            }
            Method::BasicReturn(BasicReturn {
                reply_code,
                reply_text,
                exchange,
                routing_key,
            }) => {
                writer.write_all(&[0, 60, 0, 50])?;
                short(reply_code, &mut writer)?;
                shortstr(reply_text, &mut writer)?;
                shortstr(exchange, &mut writer)?;
                shortstr(routing_key, &mut writer)?;
            }
            Method::BasicDeliver(BasicDeliver {
                consumer_tag,
                delivery_tag,
                redelivered,
                exchange,
                routing_key,
            }) => {
                writer.write_all(&[0, 60, 0, 60])?;
                shortstr(consumer_tag, &mut writer)?;
                longlong(delivery_tag, &mut writer)?;
                bit(&[redelivered], &mut writer)?;
                shortstr(exchange, &mut writer)?;
                shortstr(routing_key, &mut writer)?;
            }
            Method::BasicGet(BasicGet {
                reserved_1,
                queue,
                no_ack,
            }) => {
                writer.write_all(&[0, 60, 0, 70])?;
                short(reserved_1, &mut writer)?;
                shortstr(queue, &mut writer)?;
                bit(&[no_ack], &mut writer)?;
            }
            Method::BasicGetOk(BasicGetOk {
                delivery_tag,
                redelivered,
                exchange,
                routing_key,
                message_count,
            }) => {
                writer.write_all(&[0, 60, 0, 71])?;
                longlong(delivery_tag, &mut writer)?;
                bit(&[redelivered], &mut writer)?;
                shortstr(exchange, &mut writer)?;
                shortstr(routing_key, &mut writer)?;
                long(message_count, &mut writer)?;
            }
            Method::BasicGetEmpty(BasicGetEmpty { reserved_1 }) => {
                writer.write_all(&[0, 60, 0, 72])?;
                shortstr(reserved_1, &mut writer)?;
            }
            Method::BasicAck(BasicAck {
                delivery_tag,
                multiple,
            }) => {
                writer.write_all(&[0, 60, 0, 80])?;
                longlong(delivery_tag, &mut writer)?;
                bit(&[multiple], &mut writer)?;
            }
            Method::BasicReject(BasicReject {
                delivery_tag,
                requeue,
            }) => {
                writer.write_all(&[0, 60, 0, 90])?;
                longlong(delivery_tag, &mut writer)?;
                bit(&[requeue], &mut writer)?;
            }
            Method::BasicRecoverAsync(BasicRecoverAsync { requeue }) => {
                writer.write_all(&[0, 60, 0, 100])?;
                bit(&[requeue], &mut writer)?;
            }
            Method::BasicRecover(BasicRecover { requeue }) => {
                writer.write_all(&[0, 60, 0, 110])?;
                bit(&[requeue], &mut writer)?;
            }
            Method::BasicRecoverOk(BasicRecoverOk {}) => {
                writer.write_all(&[0, 60, 0, 111])?;
            }
            Method::TxSelect(TxSelect {}) => {
                writer.write_all(&[0, 90, 0, 10])?;
            }
            Method::TxSelectOk(TxSelectOk {}) => {
                writer.write_all(&[0, 90, 0, 11])?;
            }
            Method::TxCommit(TxCommit {}) => {
                writer.write_all(&[0, 90, 0, 20])?;
            }
            Method::TxCommitOk(TxCommitOk {}) => {
                writer.write_all(&[0, 90, 0, 21])?;
            }
            Method::TxRollback(TxRollback {}) => {
                writer.write_all(&[0, 90, 0, 30])?;
            }
            Method::TxRollbackOk(TxRollbackOk {}) => {
                writer.write_all(&[0, 90, 0, 31])?;
            }
        }
        Ok(())
    }
}

mod random {
    use crate::methods::RandomMethod;
    use amqp_core::methods::*;
    use rand::Rng;

    impl<R: Rng> RandomMethod<R> for Method {
        #[allow(unused_variables)]
        fn random(rng: &mut R) -> Self {
            match rng.gen_range(0u32..6) {
                0 => match rng.gen_range(0u32..10) {
                    0 => Method::ConnectionStart(ConnectionStart {
                        version_major: RandomMethod::random(rng),
                        version_minor: RandomMethod::random(rng),
                        server_properties: RandomMethod::random(rng),
                        mechanisms: RandomMethod::random(rng),
                        locales: RandomMethod::random(rng),
                    }),
                    1 => Method::ConnectionStartOk(ConnectionStartOk {
                        client_properties: RandomMethod::random(rng),
                        mechanism: RandomMethod::random(rng),
                        response: RandomMethod::random(rng),
                        locale: RandomMethod::random(rng),
                    }),
                    2 => Method::ConnectionSecure(ConnectionSecure {
                        challenge: RandomMethod::random(rng),
                    }),
                    3 => Method::ConnectionSecureOk(ConnectionSecureOk {
                        response: RandomMethod::random(rng),
                    }),
                    4 => Method::ConnectionTune(ConnectionTune {
                        channel_max: RandomMethod::random(rng),
                        frame_max: RandomMethod::random(rng),
                        heartbeat: RandomMethod::random(rng),
                    }),
                    5 => Method::ConnectionTuneOk(ConnectionTuneOk {
                        channel_max: RandomMethod::random(rng),
                        frame_max: RandomMethod::random(rng),
                        heartbeat: RandomMethod::random(rng),
                    }),
                    6 => Method::ConnectionOpen(ConnectionOpen {
                        virtual_host: RandomMethod::random(rng),
                        reserved_1: RandomMethod::random(rng),
                        reserved_2: RandomMethod::random(rng),
                    }),
                    7 => Method::ConnectionOpenOk(ConnectionOpenOk {
                        reserved_1: RandomMethod::random(rng),
                    }),
                    8 => Method::ConnectionClose(ConnectionClose {
                        reply_code: RandomMethod::random(rng),
                        reply_text: RandomMethod::random(rng),
                        class_id: RandomMethod::random(rng),
                        method_id: RandomMethod::random(rng),
                    }),
                    9 => Method::ConnectionCloseOk(ConnectionCloseOk {}),
                    _ => unreachable!(),
                },
                1 => match rng.gen_range(0u32..6) {
                    0 => Method::ChannelOpen(ChannelOpen {
                        reserved_1: RandomMethod::random(rng),
                    }),
                    1 => Method::ChannelOpenOk(ChannelOpenOk {
                        reserved_1: RandomMethod::random(rng),
                    }),
                    2 => Method::ChannelFlow(ChannelFlow {
                        active: RandomMethod::random(rng),
                    }),
                    3 => Method::ChannelFlowOk(ChannelFlowOk {
                        active: RandomMethod::random(rng),
                    }),
                    4 => Method::ChannelClose(ChannelClose {
                        reply_code: RandomMethod::random(rng),
                        reply_text: RandomMethod::random(rng),
                        class_id: RandomMethod::random(rng),
                        method_id: RandomMethod::random(rng),
                    }),
                    5 => Method::ChannelCloseOk(ChannelCloseOk {}),
                    _ => unreachable!(),
                },
                2 => match rng.gen_range(0u32..4) {
                    0 => Method::ExchangeDeclare(ExchangeDeclare {
                        reserved_1: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        r#type: RandomMethod::random(rng),
                        passive: RandomMethod::random(rng),
                        durable: RandomMethod::random(rng),
                        reserved_2: RandomMethod::random(rng),
                        reserved_3: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                        arguments: RandomMethod::random(rng),
                    }),
                    1 => Method::ExchangeDeclareOk(ExchangeDeclareOk {}),
                    2 => Method::ExchangeDelete(ExchangeDelete {
                        reserved_1: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        if_unused: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                    }),
                    3 => Method::ExchangeDeleteOk(ExchangeDeleteOk {}),
                    _ => unreachable!(),
                },
                3 => match rng.gen_range(0u32..10) {
                    0 => Method::QueueDeclare(QueueDeclare {
                        reserved_1: RandomMethod::random(rng),
                        queue: RandomMethod::random(rng),
                        passive: RandomMethod::random(rng),
                        durable: RandomMethod::random(rng),
                        exclusive: RandomMethod::random(rng),
                        auto_delete: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                        arguments: RandomMethod::random(rng),
                    }),
                    1 => Method::QueueDeclareOk(QueueDeclareOk {
                        queue: RandomMethod::random(rng),
                        message_count: RandomMethod::random(rng),
                        consumer_count: RandomMethod::random(rng),
                    }),
                    2 => Method::QueueBind(QueueBind {
                        reserved_1: RandomMethod::random(rng),
                        queue: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        routing_key: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                        arguments: RandomMethod::random(rng),
                    }),
                    3 => Method::QueueBindOk(QueueBindOk {}),
                    4 => Method::QueueUnbind(QueueUnbind {
                        reserved_1: RandomMethod::random(rng),
                        queue: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        routing_key: RandomMethod::random(rng),
                        arguments: RandomMethod::random(rng),
                    }),
                    5 => Method::QueueUnbindOk(QueueUnbindOk {}),
                    6 => Method::QueuePurge(QueuePurge {
                        reserved_1: RandomMethod::random(rng),
                        queue: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                    }),
                    7 => Method::QueuePurgeOk(QueuePurgeOk {
                        message_count: RandomMethod::random(rng),
                    }),
                    8 => Method::QueueDelete(QueueDelete {
                        reserved_1: RandomMethod::random(rng),
                        queue: RandomMethod::random(rng),
                        if_unused: RandomMethod::random(rng),
                        if_empty: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                    }),
                    9 => Method::QueueDeleteOk(QueueDeleteOk {
                        message_count: RandomMethod::random(rng),
                    }),
                    _ => unreachable!(),
                },
                4 => match rng.gen_range(0u32..17) {
                    0 => Method::BasicQos(BasicQos {
                        prefetch_size: RandomMethod::random(rng),
                        prefetch_count: RandomMethod::random(rng),
                        global: RandomMethod::random(rng),
                    }),
                    1 => Method::BasicQosOk(BasicQosOk {}),
                    2 => Method::BasicConsume(BasicConsume {
                        reserved_1: RandomMethod::random(rng),
                        queue: RandomMethod::random(rng),
                        consumer_tag: RandomMethod::random(rng),
                        no_local: RandomMethod::random(rng),
                        no_ack: RandomMethod::random(rng),
                        exclusive: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                        arguments: RandomMethod::random(rng),
                    }),
                    3 => Method::BasicConsumeOk(BasicConsumeOk {
                        consumer_tag: RandomMethod::random(rng),
                    }),
                    4 => Method::BasicCancel(BasicCancel {
                        consumer_tag: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                    }),
                    5 => Method::BasicCancelOk(BasicCancelOk {
                        consumer_tag: RandomMethod::random(rng),
                    }),
                    6 => Method::BasicPublish(BasicPublish {
                        reserved_1: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        routing_key: RandomMethod::random(rng),
                        mandatory: RandomMethod::random(rng),
                        immediate: RandomMethod::random(rng),
                    }),
                    7 => Method::BasicReturn(BasicReturn {
                        reply_code: RandomMethod::random(rng),
                        reply_text: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        routing_key: RandomMethod::random(rng),
                    }),
                    8 => Method::BasicDeliver(BasicDeliver {
                        consumer_tag: RandomMethod::random(rng),
                        delivery_tag: RandomMethod::random(rng),
                        redelivered: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        routing_key: RandomMethod::random(rng),
                    }),
                    9 => Method::BasicGet(BasicGet {
                        reserved_1: RandomMethod::random(rng),
                        queue: RandomMethod::random(rng),
                        no_ack: RandomMethod::random(rng),
                    }),
                    10 => Method::BasicGetOk(BasicGetOk {
                        delivery_tag: RandomMethod::random(rng),
                        redelivered: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        routing_key: RandomMethod::random(rng),
                        message_count: RandomMethod::random(rng),
                    }),
                    11 => Method::BasicGetEmpty(BasicGetEmpty {
                        reserved_1: RandomMethod::random(rng),
                    }),
                    12 => Method::BasicAck(BasicAck {
                        delivery_tag: RandomMethod::random(rng),
                        multiple: RandomMethod::random(rng),
                    }),
                    13 => Method::BasicReject(BasicReject {
                        delivery_tag: RandomMethod::random(rng),
                        requeue: RandomMethod::random(rng),
                    }),
                    14 => Method::BasicRecoverAsync(BasicRecoverAsync {
                        requeue: RandomMethod::random(rng),
                    }),
                    15 => Method::BasicRecover(BasicRecover {
                        requeue: RandomMethod::random(rng),
                    }),
                    16 => Method::BasicRecoverOk(BasicRecoverOk {}),
                    _ => unreachable!(),
                },
                5 => match rng.gen_range(0u32..6) {
                    0 => Method::TxSelect(TxSelect {}),
                    1 => Method::TxSelectOk(TxSelectOk {}),
                    2 => Method::TxCommit(TxCommit {}),
                    3 => Method::TxCommitOk(TxCommitOk {}),
                    4 => Method::TxRollback(TxRollback {}),
                    5 => Method::TxRollbackOk(TxRollbackOk {}),
                    _ => unreachable!(),
                },
                _ => unreachable!(),
            }
        }
    }
}
