#![allow(dead_code)]
// This file has been generated by `xtask/src/codegen`. Do not edit it manually.

pub type ClassId = u16;

/// consumer tag
///
/// Identifier for the consumer, valid within the current channel.
pub type ConsumerTag = String;

/// server-assigned delivery tag
///
/// The server-assigned and channel-specific delivery tag
pub type DeliveryTag = u64;

/// exchange name
///
/// must be shorter than 127, must match `^[a-zA-Z0-9-_.:]*$`
///
/// The exchange name is a client-selected string that identifies the exchange for
/// publish methods.
pub type ExchangeName = String;

pub type MethodId = u16;

/// no acknowledgement needed
///
/// If this field is set the server does not expect acknowledgements for
/// messages. That is, when a message is delivered to the client the server
/// assumes the delivery will succeed and immediately dequeues it. This
/// functionality may increase performance but at the cost of reliability.
/// Messages can get lost if a client dies before they are delivered to the
/// application.
pub type NoAck = bool;

/// do not deliver own messages
///
/// If the no-local field is set the server will not send messages to the connection that
/// published them.
pub type NoLocal = bool;

/// do not send reply method
///
/// If set, the server will not respond to the method. The client should not wait
/// for a reply method. If the server could not complete the method it will raise a
/// channel or connection exception.
pub type NoWait = bool;

/// must not be null, must be shorter than 127
///
/// Unconstrained.
pub type Path = String;

///
/// This table provides a set of peer properties, used for identification, debugging,
/// and general information.
pub type PeerProperties = super::Table;

/// queue name
///
/// must be shorter than 127, must match `^[a-zA-Z0-9-_.:]*$`
///
/// The queue name identifies the queue within the vhost.  In methods where the queue
/// name may be blank, and that has no specific significance, this refers to the
/// 'current' queue for the channel, meaning the last queue that the client declared
/// on the channel.  If the client did not declare a queue, and the method needs a
/// queue name, this will result in a 502 (syntax error) channel exception.
pub type QueueName = String;

/// message is being redelivered
///
/// This indicates that the message has been previously delivered to this or
/// another client.
pub type Redelivered = bool;

/// number of messages in queue
///
/// The number of messages in the queue, which will be zero for newly-declared
/// queues. This is the number of messages present in the queue, and committed
/// if the channel on which they were published is transacted, that are not
/// waiting acknowledgement.
pub type MessageCount = u32;

/// reply code from server
///
/// must not be null
///
/// The reply code. The AMQ reply codes are defined as constants at the start
/// of this formal specification.
pub type ReplyCode = u16;

/// localised reply text
///
/// must not be null
///
/// The localised reply text. This text can be logged as an aid to resolving
/// issues.
pub type ReplyText = String;

/// single bit
pub type Bit = bool;

/// single octet
pub type Octet = u8;

/// 16-bit integer
pub type Short = u16;

/// 32-bit integer
pub type Long = u32;

/// 64-bit integer
pub type Longlong = u64;

/// short string (max. 256 characters)
pub type Shortstr = String;

/// long string
pub type Longstr = Vec<u8>;

/// 64-bit timestamp
pub type Timestamp = u64;

/// field table
pub type Table = super::Table;

#[derive(Debug, Clone, PartialEq)]
pub enum Method {
    /// The connection class provides methods for a client to establish a network connection to
    /// a server, and for both peers to operate the connection thereafter.
    /// This method starts the connection negotiation process by telling the client the
    /// protocol version that the server proposes, along with a list of security mechanisms
    /// which the client can use for authentication.
    ConnectionStart {
        /// The major version number can take any value from 0 to 99 as defined in the
        /// AMQP specification.
        version_major: Octet,
        /// The minor version number can take any value from 0 to 99 as defined in the
        /// AMQP specification.
        version_minor: Octet,
        server_properties: PeerProperties,
        /// must not be null
        ///
        /// A list of the security mechanisms that the server supports, delimited by spaces.
        mechanisms: Longstr,
        /// must not be null
        ///
        /// A list of the message locales that the server supports, delimited by spaces. The
        /// locale defines the language in which the server will send reply texts.
        locales: Longstr,
    },
    /// The connection class provides methods for a client to establish a network connection to
    /// a server, and for both peers to operate the connection thereafter.
    /// This method selects a SASL security mechanism.
    ConnectionStartOk {
        client_properties: PeerProperties,
        /// must not be null
        ///
        /// A single security mechanisms selected by the client, which must be one of those
        /// specified by the server.
        mechanism: Shortstr,
        /// must not be null
        ///
        /// A block of opaque data passed to the security mechanism. The contents of this
        /// data are defined by the SASL security mechanism.
        response: Longstr,
        /// must not be null
        ///
        /// A single message locale selected by the client, which must be one of those
        /// specified by the server.
        locale: Shortstr,
    },
    /// The connection class provides methods for a client to establish a network connection to
    /// a server, and for both peers to operate the connection thereafter.
    /// The SASL protocol works by exchanging challenges and responses until both peers have
    /// received sufficient information to authenticate each other. This method challenges
    /// the client to provide more information.
    ConnectionSecure {
        /// Challenge information, a block of opaque binary data passed to the security
        /// mechanism.
        challenge: Longstr,
    },
    /// The connection class provides methods for a client to establish a network connection to
    /// a server, and for both peers to operate the connection thereafter.
    /// This method attempts to authenticate, passing a block of SASL data for the security
    /// mechanism at the server side.
    ConnectionSecureOk {
        /// must not be null
        ///
        /// A block of opaque data passed to the security mechanism. The contents of this
        /// data are defined by the SASL security mechanism.
        response: Longstr,
    },
    /// The connection class provides methods for a client to establish a network connection to
    /// a server, and for both peers to operate the connection thereafter.
    /// This method proposes a set of connection configuration values to the client. The
    /// client can accept and/or adjust these.
    ConnectionTune {
        /// Specifies highest channel number that the server permits.  Usable channel numbers
        /// are in the range 1..channel-max.  Zero indicates no specified limit.
        channel_max: Short,
        /// The largest frame size that the server proposes for the connection, including
        /// frame header and end-byte.  The client can negotiate a lower value. Zero means
        /// that the server does not impose any specific limit but may reject very large
        /// frames if it cannot allocate resources for them.
        frame_max: Long,
        /// The delay, in seconds, of the connection heartbeat that the server wants.
        /// Zero means the server does not want a heartbeat.
        heartbeat: Short,
    },
    /// The connection class provides methods for a client to establish a network connection to
    /// a server, and for both peers to operate the connection thereafter.
    /// This method sends the client's connection tuning parameters to the server.
    /// Certain fields are negotiated, others provide capability information.
    ConnectionTuneOk {
        /// must not be null, must be less than the tune field of the method channel-max
        ///
        /// The maximum total number of channels that the client will use per connection.
        channel_max: Short,
        /// The largest frame size that the client and server will use for the connection.
        /// Zero means that the client does not impose any specific limit but may reject
        /// very large frames if it cannot allocate resources for them. Note that the
        /// frame-max limit applies principally to content frames, where large contents can
        /// be broken into frames of arbitrary size.
        frame_max: Long,
        /// The delay, in seconds, of the connection heartbeat that the client wants. Zero
        /// means the client does not want a heartbeat.
        heartbeat: Short,
    },
    /// The connection class provides methods for a client to establish a network connection to
    /// a server, and for both peers to operate the connection thereafter.
    /// This method opens a connection to a virtual host, which is a collection of
    /// resources, and acts to separate multiple application domains within a server.
    /// The server may apply arbitrary limits per virtual host, such as the number
    /// of each type of entity that may be used, per connection and/or in total.
    ConnectionOpen {
        /// The name of the virtual host to work with.
        virtual_host: Path,
        reserved_1: Shortstr,
        reserved_2: Bit,
    },
    /// The connection class provides methods for a client to establish a network connection to
    /// a server, and for both peers to operate the connection thereafter.
    /// This method signals to the client that the connection is ready for use.
    ConnectionOpenOk { reserved_1: Shortstr },
    /// The connection class provides methods for a client to establish a network connection to
    /// a server, and for both peers to operate the connection thereafter.
    /// This method indicates that the sender wants to close the connection. This may be
    /// due to internal conditions (e.g. a forced shut-down) or due to an error handling
    /// a specific method, i.e. an exception. When a close is due to an exception, the
    /// sender provides the class and method id of the method which caused the exception.
    ConnectionClose {
        reply_code: ReplyCode,
        reply_text: ReplyText,
        /// When the close is provoked by a method exception, this is the class of the
        /// method.
        class_id: ClassId,
        /// When the close is provoked by a method exception, this is the ID of the method.
        method_id: MethodId,
    },
    /// The connection class provides methods for a client to establish a network connection to
    /// a server, and for both peers to operate the connection thereafter.
    /// This method confirms a Connection.Close method and tells the recipient that it is
    /// safe to release resources for the connection and close the socket.
    ConnectionCloseOk,
    /// The channel class provides methods for a client to establish a channel to a
    /// server and for both peers to operate the channel thereafter.
    /// This method opens a channel to the server.
    ChannelOpen { reserved_1: Shortstr },
    /// The channel class provides methods for a client to establish a channel to a
    /// server and for both peers to operate the channel thereafter.
    /// This method signals to the client that the channel is ready for use.
    ChannelOpenOk { reserved_1: Longstr },
    /// The channel class provides methods for a client to establish a channel to a
    /// server and for both peers to operate the channel thereafter.
    /// This method asks the peer to pause or restart the flow of content data sent by
    /// a consumer. This is a simple flow-control mechanism that a peer can use to avoid
    /// overflowing its queues or otherwise finding itself receiving more messages than
    /// it can process. Note that this method is not intended for window control. It does
    /// not affect contents returned by Basic.Get-Ok methods.
    ChannelFlow {
        /// If 1, the peer starts sending content frames. If 0, the peer stops sending
        /// content frames.
        active: Bit,
    },
    /// The channel class provides methods for a client to establish a channel to a
    /// server and for both peers to operate the channel thereafter.
    /// Confirms to the peer that a flow command was received and processed.
    ChannelFlowOk {
        /// Confirms the setting of the processed flow method: 1 means the peer will start
        /// sending or continue to send content frames; 0 means it will not.
        active: Bit,
    },
    /// The channel class provides methods for a client to establish a channel to a
    /// server and for both peers to operate the channel thereafter.
    /// This method indicates that the sender wants to close the channel. This may be due to
    /// internal conditions (e.g. a forced shut-down) or due to an error handling a specific
    /// method, i.e. an exception. When a close is due to an exception, the sender provides
    /// the class and method id of the method which caused the exception.
    ChannelClose {
        reply_code: ReplyCode,
        reply_text: ReplyText,
        /// When the close is provoked by a method exception, this is the class of the
        /// method.
        class_id: ClassId,
        /// When the close is provoked by a method exception, this is the ID of the method.
        method_id: MethodId,
    },
    /// The channel class provides methods for a client to establish a channel to a
    /// server and for both peers to operate the channel thereafter.
    /// This method confirms a Channel.Close method and tells the recipient that it is safe
    /// to release resources for the channel.
    ChannelCloseOk,
    /// Exchanges match and distribute messages across queues. Exchanges can be configured in
    /// the server or declared at runtime.
    /// This method creates an exchange if it does not already exist, and if the exchange
    /// exists, verifies that it is of the correct and expected class.
    ExchangeDeclare {
        reserved_1: Short,
        /// must not be null
        exchange: ExchangeName,
        /// Each exchange belongs to one of a set of exchange types implemented by the
        /// server. The exchange types define the functionality of the exchange - i.e. how
        /// messages are routed through it. It is not valid or meaningful to attempt to
        /// change the type of an existing exchange.
        r#type: Shortstr,
        /// If set, the server will reply with Declare-Ok if the exchange already
        /// exists with the same name, and raise an error if not.  The client can
        /// use this to check whether an exchange exists without modifying the
        /// server state. When set, all other method fields except name and no-wait
        /// are ignored.  A declare with both passive and no-wait has no effect.
        /// Arguments are compared for semantic equivalence.
        passive: Bit,
        /// If set when creating a new exchange, the exchange will be marked as durable.
        /// Durable exchanges remain active when a server restarts. Non-durable exchanges
        /// (transient exchanges) are purged if/when a server restarts.
        durable: Bit,
        reserved_2: Bit,
        reserved_3: Bit,
        no_wait: NoWait,
        /// A set of arguments for the declaration. The syntax and semantics of these
        /// arguments depends on the server implementation.
        arguments: Table,
    },
    /// Exchanges match and distribute messages across queues. Exchanges can be configured in
    /// the server or declared at runtime.
    /// This method confirms a Declare method and confirms the name of the exchange,
    /// essential for automatically-named exchanges.
    ExchangeDeclareOk,
    /// Exchanges match and distribute messages across queues. Exchanges can be configured in
    /// the server or declared at runtime.
    /// This method deletes an exchange. When an exchange is deleted all queue bindings on
    /// the exchange are cancelled.
    ExchangeDelete {
        reserved_1: Short,
        /// must not be null
        exchange: ExchangeName,
        /// If set, the server will only delete the exchange if it has no queue bindings. If
        /// the exchange has queue bindings the server does not delete it but raises a
        /// channel exception instead.
        if_unused: Bit,
        no_wait: NoWait,
    },
    /// Exchanges match and distribute messages across queues. Exchanges can be configured in
    /// the server or declared at runtime.
    /// This method confirms the deletion of an exchange.
    ExchangeDeleteOk,
    /// Queues store and forward messages. Queues can be configured in the server or created at
    /// runtime. Queues must be attached to at least one exchange in order to receive messages
    /// from publishers.
    /// This method creates or checks a queue. When creating a new queue the client can
    /// specify various properties that control the durability of the queue and its
    /// contents, and the level of sharing for the queue.
    QueueDeclare {
        reserved_1: Short,
        queue: QueueName,
        /// If set, the server will reply with Declare-Ok if the queue already
        /// exists with the same name, and raise an error if not.  The client can
        /// use this to check whether a queue exists without modifying the
        /// server state.  When set, all other method fields except name and no-wait
        /// are ignored.  A declare with both passive and no-wait has no effect.
        /// Arguments are compared for semantic equivalence.
        passive: Bit,
        /// If set when creating a new queue, the queue will be marked as durable. Durable
        /// queues remain active when a server restarts. Non-durable queues (transient
        /// queues) are purged if/when a server restarts. Note that durable queues do not
        /// necessarily hold persistent messages, although it does not make sense to send
        /// persistent messages to a transient queue.
        durable: Bit,
        /// Exclusive queues may only be accessed by the current connection, and are
        /// deleted when that connection closes.  Passive declaration of an exclusive
        /// queue by other connections are not allowed.
        exclusive: Bit,
        /// If set, the queue is deleted when all consumers have finished using it.  The last
        /// consumer can be cancelled either explicitly or because its channel is closed. If
        /// there was no consumer ever on the queue, it won't be deleted.  Applications can
        /// explicitly delete auto-delete queues using the Delete method as normal.
        auto_delete: Bit,
        no_wait: NoWait,
        /// A set of arguments for the declaration. The syntax and semantics of these
        /// arguments depends on the server implementation.
        arguments: Table,
    },
    /// Queues store and forward messages. Queues can be configured in the server or created at
    /// runtime. Queues must be attached to at least one exchange in order to receive messages
    /// from publishers.
    /// This method confirms a Declare method and confirms the name of the queue, essential
    /// for automatically-named queues.
    QueueDeclareOk {
        /// must not be null
        ///
        /// Reports the name of the queue. If the server generated a queue name, this field
        /// contains that name.
        queue: QueueName,
        message_count: MessageCount,
        /// Reports the number of active consumers for the queue. Note that consumers can
        /// suspend activity (Channel.Flow) in which case they do not appear in this count.
        consumer_count: Long,
    },
    /// Queues store and forward messages. Queues can be configured in the server or created at
    /// runtime. Queues must be attached to at least one exchange in order to receive messages
    /// from publishers.
    /// This method binds a queue to an exchange. Until a queue is bound it will not
    /// receive any messages. In a classic messaging model, store-and-forward queues
    /// are bound to a direct exchange and subscription queues are bound to a topic
    /// exchange.
    QueueBind {
        reserved_1: Short,
        /// Specifies the name of the queue to bind.
        queue: QueueName,
        exchange: ExchangeName,
        /// Specifies the routing key for the binding. The routing key is used for routing
        /// messages depending on the exchange configuration. Not all exchanges use a
        /// routing key - refer to the specific exchange documentation.  If the queue name
        /// is empty, the server uses the last queue declared on the channel.  If the
        /// routing key is also empty, the server uses this queue name for the routing
        /// key as well.  If the queue name is provided but the routing key is empty, the
        /// server does the binding with that empty routing key.  The meaning of empty
        /// routing keys depends on the exchange implementation.
        routing_key: Shortstr,
        no_wait: NoWait,
        /// A set of arguments for the binding. The syntax and semantics of these arguments
        /// depends on the exchange class.
        arguments: Table,
    },
    /// Queues store and forward messages. Queues can be configured in the server or created at
    /// runtime. Queues must be attached to at least one exchange in order to receive messages
    /// from publishers.
    /// This method confirms that the bind was successful.
    QueueBindOk,
    /// Queues store and forward messages. Queues can be configured in the server or created at
    /// runtime. Queues must be attached to at least one exchange in order to receive messages
    /// from publishers.
    /// This method unbinds a queue from an exchange.
    QueueUnbind {
        reserved_1: Short,
        /// Specifies the name of the queue to unbind.
        queue: QueueName,
        /// The name of the exchange to unbind from.
        exchange: ExchangeName,
        /// Specifies the routing key of the binding to unbind.
        routing_key: Shortstr,
        /// Specifies the arguments of the binding to unbind.
        arguments: Table,
    },
    /// Queues store and forward messages. Queues can be configured in the server or created at
    /// runtime. Queues must be attached to at least one exchange in order to receive messages
    /// from publishers.
    /// This method confirms that the unbind was successful.
    QueueUnbindOk,
    /// Queues store and forward messages. Queues can be configured in the server or created at
    /// runtime. Queues must be attached to at least one exchange in order to receive messages
    /// from publishers.
    /// This method removes all messages from a queue which are not awaiting
    /// acknowledgment.
    QueuePurge {
        reserved_1: Short,
        /// Specifies the name of the queue to purge.
        queue: QueueName,
        no_wait: NoWait,
    },
    /// Queues store and forward messages. Queues can be configured in the server or created at
    /// runtime. Queues must be attached to at least one exchange in order to receive messages
    /// from publishers.
    /// This method confirms the purge of a queue.
    QueuePurgeOk {
        /// Reports the number of messages purged.
        message_count: MessageCount,
    },
    /// Queues store and forward messages. Queues can be configured in the server or created at
    /// runtime. Queues must be attached to at least one exchange in order to receive messages
    /// from publishers.
    /// This method deletes a queue. When a queue is deleted any pending messages are sent
    /// to a dead-letter queue if this is defined in the server configuration, and all
    /// consumers on the queue are cancelled.
    QueueDelete {
        reserved_1: Short,
        /// Specifies the name of the queue to delete.
        queue: QueueName,
        /// If set, the server will only delete the queue if it has no consumers. If the
        /// queue has consumers the server does does not delete it but raises a channel
        /// exception instead.
        if_unused: Bit,
        /// If set, the server will only delete the queue if it has no messages.
        if_empty: Bit,
        no_wait: NoWait,
    },
    /// Queues store and forward messages. Queues can be configured in the server or created at
    /// runtime. Queues must be attached to at least one exchange in order to receive messages
    /// from publishers.
    /// This method confirms the deletion of a queue.
    QueueDeleteOk {
        /// Reports the number of messages deleted.
        message_count: MessageCount,
    },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method requests a specific quality of service. The QoS can be specified for the
    /// current channel or for all channels on the connection. The particular properties and
    /// semantics of a qos method always depend on the content class semantics. Though the
    /// qos method could in principle apply to both peers, it is currently meaningful only
    /// for the server.
    BasicQos {
        /// The client can request that messages be sent in advance so that when the client
        /// finishes processing a message, the following message is already held locally,
        /// rather than needing to be sent down the channel. Prefetching gives a performance
        /// improvement. This field specifies the prefetch window size in octets. The server
        /// will send a message in advance if it is equal to or smaller in size than the
        /// available prefetch size (and also falls into other prefetch limits). May be set
        /// to zero, meaning "no specific limit", although other prefetch limits may still
        /// apply. The prefetch-size is ignored if the no-ack option is set.
        prefetch_size: Long,
        /// Specifies a prefetch window in terms of whole messages. This field may be used
        /// in combination with the prefetch-size field; a message will only be sent in
        /// advance if both prefetch windows (and those at the channel and connection level)
        /// allow it. The prefetch-count is ignored if the no-ack option is set.
        prefetch_count: Short,
        /// By default the QoS settings apply to the current channel only. If this field is
        /// set, they are applied to the entire connection.
        global: Bit,
    },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method tells the client that the requested QoS levels could be handled by the
    /// server. The requested QoS applies to all active consumers until a new QoS is
    /// defined.
    BasicQosOk,
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method asks the server to start a "consumer", which is a transient request for
    /// messages from a specific queue. Consumers last as long as the channel they were
    /// declared on, or until the client cancels them.
    BasicConsume {
        reserved_1: Short,
        /// Specifies the name of the queue to consume from.
        queue: QueueName,
        /// Specifies the identifier for the consumer. The consumer tag is local to a
        /// channel, so two clients can use the same consumer tags. If this field is
        /// empty the server will generate a unique tag.
        consumer_tag: ConsumerTag,
        no_local: NoLocal,
        no_ack: NoAck,
        /// Request exclusive consumer access, meaning only this consumer can access the
        /// queue.
        exclusive: Bit,
        no_wait: NoWait,
        /// A set of arguments for the consume. The syntax and semantics of these
        /// arguments depends on the server implementation.
        arguments: Table,
    },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// The server provides the client with a consumer tag, which is used by the client
    /// for methods called on the consumer at a later stage.
    BasicConsumeOk {
        /// Holds the consumer tag specified by the client or provided by the server.
        consumer_tag: ConsumerTag,
    },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method cancels a consumer. This does not affect already delivered
    /// messages, but it does mean the server will not send any more messages for
    /// that consumer. The client may receive an arbitrary number of messages in
    /// between sending the cancel method and receiving the cancel-ok reply.
    BasicCancel {
        consumer_tag: ConsumerTag,
        no_wait: NoWait,
    },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method confirms that the cancellation was completed.
    BasicCancelOk { consumer_tag: ConsumerTag },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method publishes a message to a specific exchange. The message will be routed
    /// to queues as defined by the exchange configuration and distributed to any active
    /// consumers when the transaction, if any, is committed.
    BasicPublish {
        reserved_1: Short,
        /// Specifies the name of the exchange to publish to. The exchange name can be
        /// empty, meaning the default exchange. If the exchange name is specified, and that
        /// exchange does not exist, the server will raise a channel exception.
        exchange: ExchangeName,
        /// Specifies the routing key for the message. The routing key is used for routing
        /// messages depending on the exchange configuration.
        routing_key: Shortstr,
        /// This flag tells the server how to react if the message cannot be routed to a
        /// queue. If this flag is set, the server will return an unroutable message with a
        /// Return method. If this flag is zero, the server silently drops the message.
        mandatory: Bit,
        /// This flag tells the server how to react if the message cannot be routed to a
        /// queue consumer immediately. If this flag is set, the server will return an
        /// undeliverable message with a Return method. If this flag is zero, the server
        /// will queue the message, but with no guarantee that it will ever be consumed.
        immediate: Bit,
    },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method returns an undeliverable message that was published with the "immediate"
    /// flag set, or an unroutable message published with the "mandatory" flag set. The
    /// reply code and text provide information about the reason that the message was
    /// undeliverable.
    BasicReturn {
        reply_code: ReplyCode,
        reply_text: ReplyText,
        /// Specifies the name of the exchange that the message was originally published
        /// to.  May be empty, meaning the default exchange.
        exchange: ExchangeName,
        /// Specifies the routing key name specified when the message was published.
        routing_key: Shortstr,
    },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method delivers a message to the client, via a consumer. In the asynchronous
    /// message delivery model, the client starts a consumer using the Consume method, then
    /// the server responds with Deliver methods as and when messages arrive for that
    /// consumer.
    BasicDeliver {
        consumer_tag: ConsumerTag,
        delivery_tag: DeliveryTag,
        redelivered: Redelivered,
        /// Specifies the name of the exchange that the message was originally published to.
        /// May be empty, indicating the default exchange.
        exchange: ExchangeName,
        /// Specifies the routing key name specified when the message was published.
        routing_key: Shortstr,
    },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method provides a direct access to the messages in a queue using a synchronous
    /// dialogue that is designed for specific types of application where synchronous
    /// functionality is more important than performance.
    BasicGet {
        reserved_1: Short,
        /// Specifies the name of the queue to get a message from.
        queue: QueueName,
        no_ack: NoAck,
    },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method delivers a message to the client following a get method. A message
    /// delivered by 'get-ok' must be acknowledged unless the no-ack option was set in the
    /// get method.
    BasicGetOk {
        delivery_tag: DeliveryTag,
        redelivered: Redelivered,
        /// Specifies the name of the exchange that the message was originally published to.
        /// If empty, the message was published to the default exchange.
        exchange: ExchangeName,
        /// Specifies the routing key name specified when the message was published.
        routing_key: Shortstr,
        message_count: MessageCount,
    },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method tells the client that the queue has no messages available for the
    /// client.
    BasicGetEmpty { reserved_1: Shortstr },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method acknowledges one or more messages delivered via the Deliver or Get-Ok
    /// methods. The client can ask to confirm a single message or a set of messages up to
    /// and including a specific message.
    BasicAck {
        delivery_tag: DeliveryTag,
        /// If set to 1, the delivery tag is treated as "up to and including", so that the
        /// client can acknowledge multiple messages with a single method. If set to zero,
        /// the delivery tag refers to a single message. If the multiple field is 1, and the
        /// delivery tag is zero, tells the server to acknowledge all outstanding messages.
        multiple: Bit,
    },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method allows a client to reject a message. It can be used to interrupt and
    /// cancel large incoming messages, or return untreatable messages to their original
    /// queue.
    BasicReject {
        delivery_tag: DeliveryTag,
        /// If requeue is true, the server will attempt to requeue the message.  If requeue
        /// is false or the requeue  attempt fails the messages are discarded or dead-lettered.
        requeue: Bit,
    },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method asks the server to redeliver all unacknowledged messages on a
    /// specified channel. Zero or more messages may be redelivered.  This method
    /// is deprecated in favour of the synchronous Recover/Recover-Ok.
    BasicRecoverAsync {
        /// If this field is zero, the message will be redelivered to the original
        /// recipient. If this bit is 1, the server will attempt to requeue the message,
        /// potentially then delivering it to an alternative subscriber.
        requeue: Bit,
    },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method asks the server to redeliver all unacknowledged messages on a
    /// specified channel. Zero or more messages may be redelivered.  This method
    /// replaces the asynchronous Recover.
    BasicRecover {
        /// If this field is zero, the message will be redelivered to the original
        /// recipient. If this bit is 1, the server will attempt to requeue the message,
        /// potentially then delivering it to an alternative subscriber.
        requeue: Bit,
    },
    /// The Basic class provides methods that support an industry-standard messaging model.
    /// This method acknowledges a Basic.Recover method.
    BasicRecoverOk,
    /// The Tx class allows publish and ack operations to be batched into atomic
    /// units of work.  The intention is that all publish and ack requests issued
    /// within a transaction will complete successfully or none of them will.
    /// Servers SHOULD implement atomic transactions at least where all publish
    /// or ack requests affect a single queue.  Transactions that cover multiple
    /// queues may be non-atomic, given that queues can be created and destroyed
    /// asynchronously, and such events do not form part of any transaction.
    /// Further, the behaviour of transactions with respect to the immediate and
    /// mandatory flags on Basic.Publish methods is not defined.
    /// This method sets the channel to use standard transactions. The client must use this
    /// method at least once on a channel before using the Commit or Rollback methods.
    TxSelect,
    /// The Tx class allows publish and ack operations to be batched into atomic
    /// units of work.  The intention is that all publish and ack requests issued
    /// within a transaction will complete successfully or none of them will.
    /// Servers SHOULD implement atomic transactions at least where all publish
    /// or ack requests affect a single queue.  Transactions that cover multiple
    /// queues may be non-atomic, given that queues can be created and destroyed
    /// asynchronously, and such events do not form part of any transaction.
    /// Further, the behaviour of transactions with respect to the immediate and
    /// mandatory flags on Basic.Publish methods is not defined.
    /// This method confirms to the client that the channel was successfully set to use
    /// standard transactions.
    TxSelectOk,
    /// The Tx class allows publish and ack operations to be batched into atomic
    /// units of work.  The intention is that all publish and ack requests issued
    /// within a transaction will complete successfully or none of them will.
    /// Servers SHOULD implement atomic transactions at least where all publish
    /// or ack requests affect a single queue.  Transactions that cover multiple
    /// queues may be non-atomic, given that queues can be created and destroyed
    /// asynchronously, and such events do not form part of any transaction.
    /// Further, the behaviour of transactions with respect to the immediate and
    /// mandatory flags on Basic.Publish methods is not defined.
    /// This method commits all message publications and acknowledgments performed in
    /// the current transaction.  A new transaction starts immediately after a commit.
    TxCommit,
    /// The Tx class allows publish and ack operations to be batched into atomic
    /// units of work.  The intention is that all publish and ack requests issued
    /// within a transaction will complete successfully or none of them will.
    /// Servers SHOULD implement atomic transactions at least where all publish
    /// or ack requests affect a single queue.  Transactions that cover multiple
    /// queues may be non-atomic, given that queues can be created and destroyed
    /// asynchronously, and such events do not form part of any transaction.
    /// Further, the behaviour of transactions with respect to the immediate and
    /// mandatory flags on Basic.Publish methods is not defined.
    /// This method confirms to the client that the commit succeeded. Note that if a commit
    /// fails, the server raises a channel exception.
    TxCommitOk,
    /// The Tx class allows publish and ack operations to be batched into atomic
    /// units of work.  The intention is that all publish and ack requests issued
    /// within a transaction will complete successfully or none of them will.
    /// Servers SHOULD implement atomic transactions at least where all publish
    /// or ack requests affect a single queue.  Transactions that cover multiple
    /// queues may be non-atomic, given that queues can be created and destroyed
    /// asynchronously, and such events do not form part of any transaction.
    /// Further, the behaviour of transactions with respect to the immediate and
    /// mandatory flags on Basic.Publish methods is not defined.
    /// This method abandons all message publications and acknowledgments performed in
    /// the current transaction. A new transaction starts immediately after a rollback.
    /// Note that unacked messages will not be automatically redelivered by rollback;
    /// if that is required an explicit recover call should be issued.
    TxRollback,
    /// The Tx class allows publish and ack operations to be batched into atomic
    /// units of work.  The intention is that all publish and ack requests issued
    /// within a transaction will complete successfully or none of them will.
    /// Servers SHOULD implement atomic transactions at least where all publish
    /// or ack requests affect a single queue.  Transactions that cover multiple
    /// queues may be non-atomic, given that queues can be created and destroyed
    /// asynchronously, and such events do not form part of any transaction.
    /// Further, the behaviour of transactions with respect to the immediate and
    /// mandatory flags on Basic.Publish methods is not defined.
    /// This method confirms to the client that the rollback succeeded. Note that if an
    /// rollback fails, the server raises a channel exception.
    TxRollbackOk,
}

pub mod parse {
    use super::*;
    use crate::error::TransError;
    use crate::methods::parse_helper::*;
    use nom::{branch::alt, bytes::complete::tag};
    use once_cell::sync::Lazy;
    use regex::Regex;

    pub type IResult<'a, T> = nom::IResult<&'a [u8], T, TransError>;

    pub fn parse_method(input: &[u8]) -> Result<(&[u8], Method), nom::Err<TransError>> {
        alt((connection, channel, exchange, queue, basic, tx))(input)
    }
    fn domain_class_id(input: &[u8]) -> IResult<'_, ClassId> {
        short(input)
    }
    fn domain_consumer_tag(input: &[u8]) -> IResult<'_, ConsumerTag> {
        shortstr(input)
    }
    fn domain_delivery_tag(input: &[u8]) -> IResult<'_, DeliveryTag> {
        longlong(input)
    }
    fn domain_exchange_name(input: &[u8]) -> IResult<'_, ExchangeName> {
        let (input, result) = shortstr(input)?;
        if result.len() > 127 {
            fail!("value is shorter than 127 for field result")
        }
        static REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r"^[a-zA-Z0-9-_.:]*$").unwrap());
        if !REGEX.is_match(&result) {
            fail!(r"regex `^[a-zA-Z0-9-_.:]*$` did not match value for field result")
        }
        Ok((input, result))
    }
    fn domain_method_id(input: &[u8]) -> IResult<'_, MethodId> {
        short(input)
    }
    fn domain_path(input: &[u8]) -> IResult<'_, Path> {
        let (input, result) = shortstr(input)?;
        if result.is_empty() {
            fail!("string was null for field result")
        }
        if result.len() > 127 {
            fail!("value is shorter than 127 for field result")
        }
        Ok((input, result))
    }
    fn domain_peer_properties(input: &[u8]) -> IResult<'_, PeerProperties> {
        table(input)
    }
    fn domain_queue_name(input: &[u8]) -> IResult<'_, QueueName> {
        let (input, result) = shortstr(input)?;
        if result.len() > 127 {
            fail!("value is shorter than 127 for field result")
        }
        static REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r"^[a-zA-Z0-9-_.:]*$").unwrap());
        if !REGEX.is_match(&result) {
            fail!(r"regex `^[a-zA-Z0-9-_.:]*$` did not match value for field result")
        }
        Ok((input, result))
    }
    fn domain_message_count(input: &[u8]) -> IResult<'_, MessageCount> {
        long(input)
    }
    fn domain_reply_code(input: &[u8]) -> IResult<'_, ReplyCode> {
        let (input, result) = short(input)?;
        if result == 0 {
            fail!("number was 0 for field result")
        }
        Ok((input, result))
    }
    fn domain_reply_text(input: &[u8]) -> IResult<'_, ReplyText> {
        let (input, result) = shortstr(input)?;
        if result.is_empty() {
            fail!("string was null for field result")
        }
        Ok((input, result))
    }
    fn domain_octet(input: &[u8]) -> IResult<'_, Octet> {
        octet(input)
    }
    fn domain_short(input: &[u8]) -> IResult<'_, Short> {
        short(input)
    }
    fn domain_long(input: &[u8]) -> IResult<'_, Long> {
        long(input)
    }
    fn domain_longlong(input: &[u8]) -> IResult<'_, Longlong> {
        longlong(input)
    }
    fn domain_shortstr(input: &[u8]) -> IResult<'_, Shortstr> {
        shortstr(input)
    }
    fn domain_longstr(input: &[u8]) -> IResult<'_, Longstr> {
        longstr(input)
    }
    fn domain_timestamp(input: &[u8]) -> IResult<'_, Timestamp> {
        timestamp(input)
    }
    fn domain_table(input: &[u8]) -> IResult<'_, Table> {
        table(input)
    }
    fn connection(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) = tag(10_u16.to_be_bytes())(input)
            .map_err(fail_err("invalid tag for class connection"))?;
        alt((
            connection_start,
            connection_start_ok,
            connection_secure,
            connection_secure_ok,
            connection_tune,
            connection_tune_ok,
            connection_open,
            connection_open_ok,
            connection_close,
            connection_close_ok,
        ))(input)
        .map_err(fail_err("class connection"))
    }
    fn connection_start(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(10_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, version_major) =
            domain_octet(input).map_err(fail_err("field version-major in method start"))?;
        let (input, version_minor) =
            domain_octet(input).map_err(fail_err("field version-minor in method start"))?;
        let (input, server_properties) = domain_peer_properties(input)
            .map_err(fail_err("field server-properties in method start"))?;
        let (input, mechanisms) =
            domain_longstr(input).map_err(fail_err("field mechanisms in method start"))?;
        if mechanisms.is_empty() {
            fail!("string was null for field mechanisms")
        }
        let (input, locales) =
            domain_longstr(input).map_err(fail_err("field locales in method start"))?;
        if locales.is_empty() {
            fail!("string was null for field locales")
        }
        Ok((
            input,
            Method::ConnectionStart {
                version_major,
                version_minor,
                server_properties,
                mechanisms,
                locales,
            },
        ))
    }
    fn connection_start_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(11_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, client_properties) = domain_peer_properties(input)
            .map_err(fail_err("field client-properties in method start-ok"))?;
        let (input, mechanism) =
            domain_shortstr(input).map_err(fail_err("field mechanism in method start-ok"))?;
        if mechanism.is_empty() {
            fail!("string was null for field mechanism")
        }
        let (input, response) =
            domain_longstr(input).map_err(fail_err("field response in method start-ok"))?;
        if response.is_empty() {
            fail!("string was null for field response")
        }
        let (input, locale) =
            domain_shortstr(input).map_err(fail_err("field locale in method start-ok"))?;
        if locale.is_empty() {
            fail!("string was null for field locale")
        }
        Ok((
            input,
            Method::ConnectionStartOk {
                client_properties,
                mechanism,
                response,
                locale,
            },
        ))
    }
    fn connection_secure(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(20_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, challenge) =
            domain_longstr(input).map_err(fail_err("field challenge in method secure"))?;
        Ok((input, Method::ConnectionSecure { challenge }))
    }
    fn connection_secure_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(21_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, response) =
            domain_longstr(input).map_err(fail_err("field response in method secure-ok"))?;
        if response.is_empty() {
            fail!("string was null for field response")
        }
        Ok((input, Method::ConnectionSecureOk { response }))
    }
    fn connection_tune(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(30_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, channel_max) =
            domain_short(input).map_err(fail_err("field channel-max in method tune"))?;
        let (input, frame_max) =
            domain_long(input).map_err(fail_err("field frame-max in method tune"))?;
        let (input, heartbeat) =
            domain_short(input).map_err(fail_err("field heartbeat in method tune"))?;
        Ok((
            input,
            Method::ConnectionTune {
                channel_max,
                frame_max,
                heartbeat,
            },
        ))
    }
    fn connection_tune_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(31_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, channel_max) =
            domain_short(input).map_err(fail_err("field channel-max in method tune-ok"))?;
        if channel_max == 0 {
            fail!("number was 0 for field channel_max")
        }
        let (input, frame_max) =
            domain_long(input).map_err(fail_err("field frame-max in method tune-ok"))?;
        let (input, heartbeat) =
            domain_short(input).map_err(fail_err("field heartbeat in method tune-ok"))?;
        Ok((
            input,
            Method::ConnectionTuneOk {
                channel_max,
                frame_max,
                heartbeat,
            },
        ))
    }
    fn connection_open(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(40_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, virtual_host) =
            domain_path(input).map_err(fail_err("field virtual-host in method open"))?;
        let (input, reserved_1) =
            domain_shortstr(input).map_err(fail_err("field reserved-1 in method open"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field reserved-2 in method open"))?;
        let reserved_2 = bits[0];
        Ok((
            input,
            Method::ConnectionOpen {
                virtual_host,
                reserved_1,
                reserved_2,
            },
        ))
    }
    fn connection_open_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(41_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reserved_1) =
            domain_shortstr(input).map_err(fail_err("field reserved-1 in method open-ok"))?;
        Ok((input, Method::ConnectionOpenOk { reserved_1 }))
    }
    fn connection_close(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(50_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reply_code) =
            domain_reply_code(input).map_err(fail_err("field reply-code in method close"))?;
        let (input, reply_text) =
            domain_reply_text(input).map_err(fail_err("field reply-text in method close"))?;
        let (input, class_id) =
            domain_class_id(input).map_err(fail_err("field class-id in method close"))?;
        let (input, method_id) =
            domain_method_id(input).map_err(fail_err("field method-id in method close"))?;
        Ok((
            input,
            Method::ConnectionClose {
                reply_code,
                reply_text,
                class_id,
                method_id,
            },
        ))
    }
    fn connection_close_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(51_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        Ok((input, Method::ConnectionCloseOk {}))
    }
    fn channel(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(20_u16.to_be_bytes())(input).map_err(fail_err("invalid tag for class channel"))?;
        alt((
            channel_open,
            channel_open_ok,
            channel_flow,
            channel_flow_ok,
            channel_close,
            channel_close_ok,
        ))(input)
        .map_err(fail_err("class channel"))
    }
    fn channel_open(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(10_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reserved_1) =
            domain_shortstr(input).map_err(fail_err("field reserved-1 in method open"))?;
        Ok((input, Method::ChannelOpen { reserved_1 }))
    }
    fn channel_open_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(11_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reserved_1) =
            domain_longstr(input).map_err(fail_err("field reserved-1 in method open-ok"))?;
        Ok((input, Method::ChannelOpenOk { reserved_1 }))
    }
    fn channel_flow(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(20_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field active in method flow"))?;
        let active = bits[0];
        Ok((input, Method::ChannelFlow { active }))
    }
    fn channel_flow_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(21_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field active in method flow-ok"))?;
        let active = bits[0];
        Ok((input, Method::ChannelFlowOk { active }))
    }
    fn channel_close(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(40_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reply_code) =
            domain_reply_code(input).map_err(fail_err("field reply-code in method close"))?;
        let (input, reply_text) =
            domain_reply_text(input).map_err(fail_err("field reply-text in method close"))?;
        let (input, class_id) =
            domain_class_id(input).map_err(fail_err("field class-id in method close"))?;
        let (input, method_id) =
            domain_method_id(input).map_err(fail_err("field method-id in method close"))?;
        Ok((
            input,
            Method::ChannelClose {
                reply_code,
                reply_text,
                class_id,
                method_id,
            },
        ))
    }
    fn channel_close_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(41_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        Ok((input, Method::ChannelCloseOk {}))
    }
    fn exchange(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(40_u16.to_be_bytes())(input).map_err(fail_err("invalid tag for class exchange"))?;
        alt((
            exchange_declare,
            exchange_declare_ok,
            exchange_delete,
            exchange_delete_ok,
        ))(input)
        .map_err(fail_err("class exchange"))
    }
    fn exchange_declare(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(10_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method declare"))?;
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method declare"))?;
        if exchange.is_empty() {
            fail!("string was null for field exchange")
        }
        let (input, r#type) =
            domain_shortstr(input).map_err(fail_err("field type in method declare"))?;
        let (input, bits) = bit(input, 5).map_err(fail_err("field passive in method declare"))?;
        let passive = bits[0];
        let durable = bits[1];
        let reserved_2 = bits[2];
        let reserved_3 = bits[3];
        let no_wait = bits[4];
        let (input, arguments) =
            domain_table(input).map_err(fail_err("field arguments in method declare"))?;
        Ok((
            input,
            Method::ExchangeDeclare {
                reserved_1,
                exchange,
                r#type,
                passive,
                durable,
                reserved_2,
                reserved_3,
                no_wait,
                arguments,
            },
        ))
    }
    fn exchange_declare_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(11_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        Ok((input, Method::ExchangeDeclareOk {}))
    }
    fn exchange_delete(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(20_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method delete"))?;
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method delete"))?;
        if exchange.is_empty() {
            fail!("string was null for field exchange")
        }
        let (input, bits) = bit(input, 2).map_err(fail_err("field if-unused in method delete"))?;
        let if_unused = bits[0];
        let no_wait = bits[1];
        Ok((
            input,
            Method::ExchangeDelete {
                reserved_1,
                exchange,
                if_unused,
                no_wait,
            },
        ))
    }
    fn exchange_delete_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(21_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        Ok((input, Method::ExchangeDeleteOk {}))
    }
    fn queue(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(50_u16.to_be_bytes())(input).map_err(fail_err("invalid tag for class queue"))?;
        alt((
            queue_declare,
            queue_declare_ok,
            queue_bind,
            queue_bind_ok,
            queue_unbind,
            queue_unbind_ok,
            queue_purge,
            queue_purge_ok,
            queue_delete,
            queue_delete_ok,
        ))(input)
        .map_err(fail_err("class queue"))
    }
    fn queue_declare(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(10_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method declare"))?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method declare"))?;
        let (input, bits) = bit(input, 5).map_err(fail_err("field passive in method declare"))?;
        let passive = bits[0];
        let durable = bits[1];
        let exclusive = bits[2];
        let auto_delete = bits[3];
        let no_wait = bits[4];
        let (input, arguments) =
            domain_table(input).map_err(fail_err("field arguments in method declare"))?;
        Ok((
            input,
            Method::QueueDeclare {
                reserved_1,
                queue,
                passive,
                durable,
                exclusive,
                auto_delete,
                no_wait,
                arguments,
            },
        ))
    }
    fn queue_declare_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(11_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method declare-ok"))?;
        if queue.is_empty() {
            fail!("string was null for field queue")
        }
        let (input, message_count) = domain_message_count(input)
            .map_err(fail_err("field message-count in method declare-ok"))?;
        let (input, consumer_count) =
            domain_long(input).map_err(fail_err("field consumer-count in method declare-ok"))?;
        Ok((
            input,
            Method::QueueDeclareOk {
                queue,
                message_count,
                consumer_count,
            },
        ))
    }
    fn queue_bind(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(20_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method bind"))?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method bind"))?;
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method bind"))?;
        let (input, routing_key) =
            domain_shortstr(input).map_err(fail_err("field routing-key in method bind"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field no-wait in method bind"))?;
        let no_wait = bits[0];
        let (input, arguments) =
            domain_table(input).map_err(fail_err("field arguments in method bind"))?;
        Ok((
            input,
            Method::QueueBind {
                reserved_1,
                queue,
                exchange,
                routing_key,
                no_wait,
                arguments,
            },
        ))
    }
    fn queue_bind_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(21_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        Ok((input, Method::QueueBindOk {}))
    }
    fn queue_unbind(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(50_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method unbind"))?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method unbind"))?;
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method unbind"))?;
        let (input, routing_key) =
            domain_shortstr(input).map_err(fail_err("field routing-key in method unbind"))?;
        let (input, arguments) =
            domain_table(input).map_err(fail_err("field arguments in method unbind"))?;
        Ok((
            input,
            Method::QueueUnbind {
                reserved_1,
                queue,
                exchange,
                routing_key,
                arguments,
            },
        ))
    }
    fn queue_unbind_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(51_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        Ok((input, Method::QueueUnbindOk {}))
    }
    fn queue_purge(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(30_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method purge"))?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method purge"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field no-wait in method purge"))?;
        let no_wait = bits[0];
        Ok((
            input,
            Method::QueuePurge {
                reserved_1,
                queue,
                no_wait,
            },
        ))
    }
    fn queue_purge_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(31_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, message_count) = domain_message_count(input)
            .map_err(fail_err("field message-count in method purge-ok"))?;
        Ok((input, Method::QueuePurgeOk { message_count }))
    }
    fn queue_delete(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(40_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method delete"))?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method delete"))?;
        let (input, bits) = bit(input, 3).map_err(fail_err("field if-unused in method delete"))?;
        let if_unused = bits[0];
        let if_empty = bits[1];
        let no_wait = bits[2];
        Ok((
            input,
            Method::QueueDelete {
                reserved_1,
                queue,
                if_unused,
                if_empty,
                no_wait,
            },
        ))
    }
    fn queue_delete_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(41_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, message_count) = domain_message_count(input)
            .map_err(fail_err("field message-count in method delete-ok"))?;
        Ok((input, Method::QueueDeleteOk { message_count }))
    }
    fn basic(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(60_u16.to_be_bytes())(input).map_err(fail_err("invalid tag for class basic"))?;
        alt((
            basic_qos,
            basic_qos_ok,
            basic_consume,
            basic_consume_ok,
            basic_cancel,
            basic_cancel_ok,
            basic_publish,
            basic_return,
            basic_deliver,
            basic_get,
            basic_get_ok,
            basic_get_empty,
            basic_ack,
            basic_reject,
            basic_recover_async,
            basic_recover,
            basic_recover_ok,
        ))(input)
        .map_err(fail_err("class basic"))
    }
    fn basic_qos(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(10_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, prefetch_size) =
            domain_long(input).map_err(fail_err("field prefetch-size in method qos"))?;
        let (input, prefetch_count) =
            domain_short(input).map_err(fail_err("field prefetch-count in method qos"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field global in method qos"))?;
        let global = bits[0];
        Ok((
            input,
            Method::BasicQos {
                prefetch_size,
                prefetch_count,
                global,
            },
        ))
    }
    fn basic_qos_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(11_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        Ok((input, Method::BasicQosOk {}))
    }
    fn basic_consume(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(20_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method consume"))?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method consume"))?;
        let (input, consumer_tag) =
            domain_consumer_tag(input).map_err(fail_err("field consumer-tag in method consume"))?;
        let (input, bits) = bit(input, 4).map_err(fail_err("field no-local in method consume"))?;
        let no_local = bits[0];
        let no_ack = bits[1];
        let exclusive = bits[2];
        let no_wait = bits[3];
        let (input, arguments) =
            domain_table(input).map_err(fail_err("field arguments in method consume"))?;
        Ok((
            input,
            Method::BasicConsume {
                reserved_1,
                queue,
                consumer_tag,
                no_local,
                no_ack,
                exclusive,
                no_wait,
                arguments,
            },
        ))
    }
    fn basic_consume_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(21_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, consumer_tag) = domain_consumer_tag(input)
            .map_err(fail_err("field consumer-tag in method consume-ok"))?;
        Ok((input, Method::BasicConsumeOk { consumer_tag }))
    }
    fn basic_cancel(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(30_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, consumer_tag) =
            domain_consumer_tag(input).map_err(fail_err("field consumer-tag in method cancel"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field no-wait in method cancel"))?;
        let no_wait = bits[0];
        Ok((
            input,
            Method::BasicCancel {
                consumer_tag,
                no_wait,
            },
        ))
    }
    fn basic_cancel_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(31_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, consumer_tag) = domain_consumer_tag(input)
            .map_err(fail_err("field consumer-tag in method cancel-ok"))?;
        Ok((input, Method::BasicCancelOk { consumer_tag }))
    }
    fn basic_publish(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(40_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method publish"))?;
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method publish"))?;
        let (input, routing_key) =
            domain_shortstr(input).map_err(fail_err("field routing-key in method publish"))?;
        let (input, bits) = bit(input, 2).map_err(fail_err("field mandatory in method publish"))?;
        let mandatory = bits[0];
        let immediate = bits[1];
        Ok((
            input,
            Method::BasicPublish {
                reserved_1,
                exchange,
                routing_key,
                mandatory,
                immediate,
            },
        ))
    }
    fn basic_return(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(50_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reply_code) =
            domain_reply_code(input).map_err(fail_err("field reply-code in method return"))?;
        let (input, reply_text) =
            domain_reply_text(input).map_err(fail_err("field reply-text in method return"))?;
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method return"))?;
        let (input, routing_key) =
            domain_shortstr(input).map_err(fail_err("field routing-key in method return"))?;
        Ok((
            input,
            Method::BasicReturn {
                reply_code,
                reply_text,
                exchange,
                routing_key,
            },
        ))
    }
    fn basic_deliver(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(60_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, consumer_tag) =
            domain_consumer_tag(input).map_err(fail_err("field consumer-tag in method deliver"))?;
        let (input, delivery_tag) =
            domain_delivery_tag(input).map_err(fail_err("field delivery-tag in method deliver"))?;
        let (input, bits) =
            bit(input, 1).map_err(fail_err("field redelivered in method deliver"))?;
        let redelivered = bits[0];
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method deliver"))?;
        let (input, routing_key) =
            domain_shortstr(input).map_err(fail_err("field routing-key in method deliver"))?;
        Ok((
            input,
            Method::BasicDeliver {
                consumer_tag,
                delivery_tag,
                redelivered,
                exchange,
                routing_key,
            },
        ))
    }
    fn basic_get(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(70_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reserved_1) =
            domain_short(input).map_err(fail_err("field reserved-1 in method get"))?;
        let (input, queue) =
            domain_queue_name(input).map_err(fail_err("field queue in method get"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field no-ack in method get"))?;
        let no_ack = bits[0];
        Ok((
            input,
            Method::BasicGet {
                reserved_1,
                queue,
                no_ack,
            },
        ))
    }
    fn basic_get_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(71_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, delivery_tag) =
            domain_delivery_tag(input).map_err(fail_err("field delivery-tag in method get-ok"))?;
        let (input, bits) =
            bit(input, 1).map_err(fail_err("field redelivered in method get-ok"))?;
        let redelivered = bits[0];
        let (input, exchange) =
            domain_exchange_name(input).map_err(fail_err("field exchange in method get-ok"))?;
        let (input, routing_key) =
            domain_shortstr(input).map_err(fail_err("field routing-key in method get-ok"))?;
        let (input, message_count) = domain_message_count(input)
            .map_err(fail_err("field message-count in method get-ok"))?;
        Ok((
            input,
            Method::BasicGetOk {
                delivery_tag,
                redelivered,
                exchange,
                routing_key,
                message_count,
            },
        ))
    }
    fn basic_get_empty(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(72_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, reserved_1) =
            domain_shortstr(input).map_err(fail_err("field reserved-1 in method get-empty"))?;
        Ok((input, Method::BasicGetEmpty { reserved_1 }))
    }
    fn basic_ack(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(80_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, delivery_tag) =
            domain_delivery_tag(input).map_err(fail_err("field delivery-tag in method ack"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field multiple in method ack"))?;
        let multiple = bits[0];
        Ok((
            input,
            Method::BasicAck {
                delivery_tag,
                multiple,
            },
        ))
    }
    fn basic_reject(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(90_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, delivery_tag) =
            domain_delivery_tag(input).map_err(fail_err("field delivery-tag in method reject"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field requeue in method reject"))?;
        let requeue = bits[0];
        Ok((
            input,
            Method::BasicReject {
                delivery_tag,
                requeue,
            },
        ))
    }
    fn basic_recover_async(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(100_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, bits) =
            bit(input, 1).map_err(fail_err("field requeue in method recover-async"))?;
        let requeue = bits[0];
        Ok((input, Method::BasicRecoverAsync { requeue }))
    }
    fn basic_recover(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(110_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        let (input, bits) = bit(input, 1).map_err(fail_err("field requeue in method recover"))?;
        let requeue = bits[0];
        Ok((input, Method::BasicRecover { requeue }))
    }
    fn basic_recover_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(111_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        Ok((input, Method::BasicRecoverOk {}))
    }
    fn tx(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(90_u16.to_be_bytes())(input).map_err(fail_err("invalid tag for class tx"))?;
        alt((
            tx_select,
            tx_select_ok,
            tx_commit,
            tx_commit_ok,
            tx_rollback,
            tx_rollback_ok,
        ))(input)
        .map_err(fail_err("class tx"))
    }
    fn tx_select(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(10_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        Ok((input, Method::TxSelect {}))
    }
    fn tx_select_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(11_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        Ok((input, Method::TxSelectOk {}))
    }
    fn tx_commit(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(20_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        Ok((input, Method::TxCommit {}))
    }
    fn tx_commit_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(21_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        Ok((input, Method::TxCommitOk {}))
    }
    fn tx_rollback(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(30_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        Ok((input, Method::TxRollback {}))
    }
    fn tx_rollback_ok(input: &[u8]) -> IResult<'_, Method> {
        let (input, _) =
            tag(31_u16.to_be_bytes())(input).map_err(fail_err("parsing method index"))?;
        Ok((input, Method::TxRollbackOk {}))
    }
}
pub mod write {
    use super::*;
    use crate::error::TransError;
    use crate::methods::write_helper::*;
    use std::io::Write;

    pub fn write_method<W: Write>(method: Method, mut writer: W) -> Result<(), TransError> {
        match method {
            Method::ConnectionStart {
                version_major,
                version_minor,
                server_properties,
                mechanisms,
                locales,
            } => {
                writer.write_all(&[0, 10, 0, 10])?;
                octet(version_major, &mut writer)?;
                octet(version_minor, &mut writer)?;
                table(server_properties, &mut writer)?;
                longstr(mechanisms, &mut writer)?;
                longstr(locales, &mut writer)?;
            }
            Method::ConnectionStartOk {
                client_properties,
                mechanism,
                response,
                locale,
            } => {
                writer.write_all(&[0, 10, 0, 11])?;
                table(client_properties, &mut writer)?;
                shortstr(mechanism, &mut writer)?;
                longstr(response, &mut writer)?;
                shortstr(locale, &mut writer)?;
            }
            Method::ConnectionSecure { challenge } => {
                writer.write_all(&[0, 10, 0, 20])?;
                longstr(challenge, &mut writer)?;
            }
            Method::ConnectionSecureOk { response } => {
                writer.write_all(&[0, 10, 0, 21])?;
                longstr(response, &mut writer)?;
            }
            Method::ConnectionTune {
                channel_max,
                frame_max,
                heartbeat,
            } => {
                writer.write_all(&[0, 10, 0, 30])?;
                short(channel_max, &mut writer)?;
                long(frame_max, &mut writer)?;
                short(heartbeat, &mut writer)?;
            }
            Method::ConnectionTuneOk {
                channel_max,
                frame_max,
                heartbeat,
            } => {
                writer.write_all(&[0, 10, 0, 31])?;
                short(channel_max, &mut writer)?;
                long(frame_max, &mut writer)?;
                short(heartbeat, &mut writer)?;
            }
            Method::ConnectionOpen {
                virtual_host,
                reserved_1,
                reserved_2,
            } => {
                writer.write_all(&[0, 10, 0, 40])?;
                shortstr(virtual_host, &mut writer)?;
                shortstr(reserved_1, &mut writer)?;
                bit(&[reserved_2], &mut writer)?;
            }
            Method::ConnectionOpenOk { reserved_1 } => {
                writer.write_all(&[0, 10, 0, 41])?;
                shortstr(reserved_1, &mut writer)?;
            }
            Method::ConnectionClose {
                reply_code,
                reply_text,
                class_id,
                method_id,
            } => {
                writer.write_all(&[0, 10, 0, 50])?;
                short(reply_code, &mut writer)?;
                shortstr(reply_text, &mut writer)?;
                short(class_id, &mut writer)?;
                short(method_id, &mut writer)?;
            }
            Method::ConnectionCloseOk {} => {
                writer.write_all(&[0, 10, 0, 51])?;
            }
            Method::ChannelOpen { reserved_1 } => {
                writer.write_all(&[0, 20, 0, 10])?;
                shortstr(reserved_1, &mut writer)?;
            }
            Method::ChannelOpenOk { reserved_1 } => {
                writer.write_all(&[0, 20, 0, 11])?;
                longstr(reserved_1, &mut writer)?;
            }
            Method::ChannelFlow { active } => {
                writer.write_all(&[0, 20, 0, 20])?;
                bit(&[active], &mut writer)?;
            }
            Method::ChannelFlowOk { active } => {
                writer.write_all(&[0, 20, 0, 21])?;
                bit(&[active], &mut writer)?;
            }
            Method::ChannelClose {
                reply_code,
                reply_text,
                class_id,
                method_id,
            } => {
                writer.write_all(&[0, 20, 0, 40])?;
                short(reply_code, &mut writer)?;
                shortstr(reply_text, &mut writer)?;
                short(class_id, &mut writer)?;
                short(method_id, &mut writer)?;
            }
            Method::ChannelCloseOk {} => {
                writer.write_all(&[0, 20, 0, 41])?;
            }
            Method::ExchangeDeclare {
                reserved_1,
                exchange,
                r#type,
                passive,
                durable,
                reserved_2,
                reserved_3,
                no_wait,
                arguments,
            } => {
                writer.write_all(&[0, 40, 0, 10])?;
                short(reserved_1, &mut writer)?;
                shortstr(exchange, &mut writer)?;
                shortstr(r#type, &mut writer)?;
                bit(
                    &[passive, durable, reserved_2, reserved_3, no_wait],
                    &mut writer,
                )?;
                table(arguments, &mut writer)?;
            }
            Method::ExchangeDeclareOk {} => {
                writer.write_all(&[0, 40, 0, 11])?;
            }
            Method::ExchangeDelete {
                reserved_1,
                exchange,
                if_unused,
                no_wait,
            } => {
                writer.write_all(&[0, 40, 0, 20])?;
                short(reserved_1, &mut writer)?;
                shortstr(exchange, &mut writer)?;
                bit(&[if_unused, no_wait], &mut writer)?;
            }
            Method::ExchangeDeleteOk {} => {
                writer.write_all(&[0, 40, 0, 21])?;
            }
            Method::QueueDeclare {
                reserved_1,
                queue,
                passive,
                durable,
                exclusive,
                auto_delete,
                no_wait,
                arguments,
            } => {
                writer.write_all(&[0, 50, 0, 10])?;
                short(reserved_1, &mut writer)?;
                shortstr(queue, &mut writer)?;
                bit(
                    &[passive, durable, exclusive, auto_delete, no_wait],
                    &mut writer,
                )?;
                table(arguments, &mut writer)?;
            }
            Method::QueueDeclareOk {
                queue,
                message_count,
                consumer_count,
            } => {
                writer.write_all(&[0, 50, 0, 11])?;
                shortstr(queue, &mut writer)?;
                long(message_count, &mut writer)?;
                long(consumer_count, &mut writer)?;
            }
            Method::QueueBind {
                reserved_1,
                queue,
                exchange,
                routing_key,
                no_wait,
                arguments,
            } => {
                writer.write_all(&[0, 50, 0, 20])?;
                short(reserved_1, &mut writer)?;
                shortstr(queue, &mut writer)?;
                shortstr(exchange, &mut writer)?;
                shortstr(routing_key, &mut writer)?;
                bit(&[no_wait], &mut writer)?;
                table(arguments, &mut writer)?;
            }
            Method::QueueBindOk {} => {
                writer.write_all(&[0, 50, 0, 21])?;
            }
            Method::QueueUnbind {
                reserved_1,
                queue,
                exchange,
                routing_key,
                arguments,
            } => {
                writer.write_all(&[0, 50, 0, 50])?;
                short(reserved_1, &mut writer)?;
                shortstr(queue, &mut writer)?;
                shortstr(exchange, &mut writer)?;
                shortstr(routing_key, &mut writer)?;
                table(arguments, &mut writer)?;
            }
            Method::QueueUnbindOk {} => {
                writer.write_all(&[0, 50, 0, 51])?;
            }
            Method::QueuePurge {
                reserved_1,
                queue,
                no_wait,
            } => {
                writer.write_all(&[0, 50, 0, 30])?;
                short(reserved_1, &mut writer)?;
                shortstr(queue, &mut writer)?;
                bit(&[no_wait], &mut writer)?;
            }
            Method::QueuePurgeOk { message_count } => {
                writer.write_all(&[0, 50, 0, 31])?;
                long(message_count, &mut writer)?;
            }
            Method::QueueDelete {
                reserved_1,
                queue,
                if_unused,
                if_empty,
                no_wait,
            } => {
                writer.write_all(&[0, 50, 0, 40])?;
                short(reserved_1, &mut writer)?;
                shortstr(queue, &mut writer)?;
                bit(&[if_unused, if_empty, no_wait], &mut writer)?;
            }
            Method::QueueDeleteOk { message_count } => {
                writer.write_all(&[0, 50, 0, 41])?;
                long(message_count, &mut writer)?;
            }
            Method::BasicQos {
                prefetch_size,
                prefetch_count,
                global,
            } => {
                writer.write_all(&[0, 60, 0, 10])?;
                long(prefetch_size, &mut writer)?;
                short(prefetch_count, &mut writer)?;
                bit(&[global], &mut writer)?;
            }
            Method::BasicQosOk {} => {
                writer.write_all(&[0, 60, 0, 11])?;
            }
            Method::BasicConsume {
                reserved_1,
                queue,
                consumer_tag,
                no_local,
                no_ack,
                exclusive,
                no_wait,
                arguments,
            } => {
                writer.write_all(&[0, 60, 0, 20])?;
                short(reserved_1, &mut writer)?;
                shortstr(queue, &mut writer)?;
                shortstr(consumer_tag, &mut writer)?;
                bit(&[no_local, no_ack, exclusive, no_wait], &mut writer)?;
                table(arguments, &mut writer)?;
            }
            Method::BasicConsumeOk { consumer_tag } => {
                writer.write_all(&[0, 60, 0, 21])?;
                shortstr(consumer_tag, &mut writer)?;
            }
            Method::BasicCancel {
                consumer_tag,
                no_wait,
            } => {
                writer.write_all(&[0, 60, 0, 30])?;
                shortstr(consumer_tag, &mut writer)?;
                bit(&[no_wait], &mut writer)?;
            }
            Method::BasicCancelOk { consumer_tag } => {
                writer.write_all(&[0, 60, 0, 31])?;
                shortstr(consumer_tag, &mut writer)?;
            }
            Method::BasicPublish {
                reserved_1,
                exchange,
                routing_key,
                mandatory,
                immediate,
            } => {
                writer.write_all(&[0, 60, 0, 40])?;
                short(reserved_1, &mut writer)?;
                shortstr(exchange, &mut writer)?;
                shortstr(routing_key, &mut writer)?;
                bit(&[mandatory, immediate], &mut writer)?;
            }
            Method::BasicReturn {
                reply_code,
                reply_text,
                exchange,
                routing_key,
            } => {
                writer.write_all(&[0, 60, 0, 50])?;
                short(reply_code, &mut writer)?;
                shortstr(reply_text, &mut writer)?;
                shortstr(exchange, &mut writer)?;
                shortstr(routing_key, &mut writer)?;
            }
            Method::BasicDeliver {
                consumer_tag,
                delivery_tag,
                redelivered,
                exchange,
                routing_key,
            } => {
                writer.write_all(&[0, 60, 0, 60])?;
                shortstr(consumer_tag, &mut writer)?;
                longlong(delivery_tag, &mut writer)?;
                bit(&[redelivered], &mut writer)?;
                shortstr(exchange, &mut writer)?;
                shortstr(routing_key, &mut writer)?;
            }
            Method::BasicGet {
                reserved_1,
                queue,
                no_ack,
            } => {
                writer.write_all(&[0, 60, 0, 70])?;
                short(reserved_1, &mut writer)?;
                shortstr(queue, &mut writer)?;
                bit(&[no_ack], &mut writer)?;
            }
            Method::BasicGetOk {
                delivery_tag,
                redelivered,
                exchange,
                routing_key,
                message_count,
            } => {
                writer.write_all(&[0, 60, 0, 71])?;
                longlong(delivery_tag, &mut writer)?;
                bit(&[redelivered], &mut writer)?;
                shortstr(exchange, &mut writer)?;
                shortstr(routing_key, &mut writer)?;
                long(message_count, &mut writer)?;
            }
            Method::BasicGetEmpty { reserved_1 } => {
                writer.write_all(&[0, 60, 0, 72])?;
                shortstr(reserved_1, &mut writer)?;
            }
            Method::BasicAck {
                delivery_tag,
                multiple,
            } => {
                writer.write_all(&[0, 60, 0, 80])?;
                longlong(delivery_tag, &mut writer)?;
                bit(&[multiple], &mut writer)?;
            }
            Method::BasicReject {
                delivery_tag,
                requeue,
            } => {
                writer.write_all(&[0, 60, 0, 90])?;
                longlong(delivery_tag, &mut writer)?;
                bit(&[requeue], &mut writer)?;
            }
            Method::BasicRecoverAsync { requeue } => {
                writer.write_all(&[0, 60, 0, 100])?;
                bit(&[requeue], &mut writer)?;
            }
            Method::BasicRecover { requeue } => {
                writer.write_all(&[0, 60, 0, 110])?;
                bit(&[requeue], &mut writer)?;
            }
            Method::BasicRecoverOk {} => {
                writer.write_all(&[0, 60, 0, 111])?;
            }
            Method::TxSelect {} => {
                writer.write_all(&[0, 90, 0, 10])?;
            }
            Method::TxSelectOk {} => {
                writer.write_all(&[0, 90, 0, 11])?;
            }
            Method::TxCommit {} => {
                writer.write_all(&[0, 90, 0, 20])?;
            }
            Method::TxCommitOk {} => {
                writer.write_all(&[0, 90, 0, 21])?;
            }
            Method::TxRollback {} => {
                writer.write_all(&[0, 90, 0, 30])?;
            }
            Method::TxRollbackOk {} => {
                writer.write_all(&[0, 90, 0, 31])?;
            }
        }
        Ok(())
    }
}
#[cfg(test)]
mod random {
    use super::*;
    use crate::methods::tests::RandomMethod;
    use rand::Rng;

    impl<R: Rng> RandomMethod<R> for Method {
        #[allow(unused_variables)]
        fn random(rng: &mut R) -> Self {
            match rng.gen_range(0u32..6) {
                0 => match rng.gen_range(0u32..10) {
                    0 => Method::ConnectionStart {
                        version_major: RandomMethod::random(rng),
                        version_minor: RandomMethod::random(rng),
                        server_properties: RandomMethod::random(rng),
                        mechanisms: RandomMethod::random(rng),
                        locales: RandomMethod::random(rng),
                    },
                    1 => Method::ConnectionStartOk {
                        client_properties: RandomMethod::random(rng),
                        mechanism: RandomMethod::random(rng),
                        response: RandomMethod::random(rng),
                        locale: RandomMethod::random(rng),
                    },
                    2 => Method::ConnectionSecure {
                        challenge: RandomMethod::random(rng),
                    },
                    3 => Method::ConnectionSecureOk {
                        response: RandomMethod::random(rng),
                    },
                    4 => Method::ConnectionTune {
                        channel_max: RandomMethod::random(rng),
                        frame_max: RandomMethod::random(rng),
                        heartbeat: RandomMethod::random(rng),
                    },
                    5 => Method::ConnectionTuneOk {
                        channel_max: RandomMethod::random(rng),
                        frame_max: RandomMethod::random(rng),
                        heartbeat: RandomMethod::random(rng),
                    },
                    6 => Method::ConnectionOpen {
                        virtual_host: RandomMethod::random(rng),
                        reserved_1: RandomMethod::random(rng),
                        reserved_2: RandomMethod::random(rng),
                    },
                    7 => Method::ConnectionOpenOk {
                        reserved_1: RandomMethod::random(rng),
                    },
                    8 => Method::ConnectionClose {
                        reply_code: RandomMethod::random(rng),
                        reply_text: RandomMethod::random(rng),
                        class_id: RandomMethod::random(rng),
                        method_id: RandomMethod::random(rng),
                    },
                    9 => Method::ConnectionCloseOk {},
                    _ => unreachable!(),
                },
                1 => match rng.gen_range(0u32..6) {
                    0 => Method::ChannelOpen {
                        reserved_1: RandomMethod::random(rng),
                    },
                    1 => Method::ChannelOpenOk {
                        reserved_1: RandomMethod::random(rng),
                    },
                    2 => Method::ChannelFlow {
                        active: RandomMethod::random(rng),
                    },
                    3 => Method::ChannelFlowOk {
                        active: RandomMethod::random(rng),
                    },
                    4 => Method::ChannelClose {
                        reply_code: RandomMethod::random(rng),
                        reply_text: RandomMethod::random(rng),
                        class_id: RandomMethod::random(rng),
                        method_id: RandomMethod::random(rng),
                    },
                    5 => Method::ChannelCloseOk {},
                    _ => unreachable!(),
                },
                2 => match rng.gen_range(0u32..4) {
                    0 => Method::ExchangeDeclare {
                        reserved_1: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        r#type: RandomMethod::random(rng),
                        passive: RandomMethod::random(rng),
                        durable: RandomMethod::random(rng),
                        reserved_2: RandomMethod::random(rng),
                        reserved_3: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                        arguments: RandomMethod::random(rng),
                    },
                    1 => Method::ExchangeDeclareOk {},
                    2 => Method::ExchangeDelete {
                        reserved_1: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        if_unused: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                    },
                    3 => Method::ExchangeDeleteOk {},
                    _ => unreachable!(),
                },
                3 => match rng.gen_range(0u32..10) {
                    0 => Method::QueueDeclare {
                        reserved_1: RandomMethod::random(rng),
                        queue: RandomMethod::random(rng),
                        passive: RandomMethod::random(rng),
                        durable: RandomMethod::random(rng),
                        exclusive: RandomMethod::random(rng),
                        auto_delete: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                        arguments: RandomMethod::random(rng),
                    },
                    1 => Method::QueueDeclareOk {
                        queue: RandomMethod::random(rng),
                        message_count: RandomMethod::random(rng),
                        consumer_count: RandomMethod::random(rng),
                    },
                    2 => Method::QueueBind {
                        reserved_1: RandomMethod::random(rng),
                        queue: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        routing_key: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                        arguments: RandomMethod::random(rng),
                    },
                    3 => Method::QueueBindOk {},
                    4 => Method::QueueUnbind {
                        reserved_1: RandomMethod::random(rng),
                        queue: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        routing_key: RandomMethod::random(rng),
                        arguments: RandomMethod::random(rng),
                    },
                    5 => Method::QueueUnbindOk {},
                    6 => Method::QueuePurge {
                        reserved_1: RandomMethod::random(rng),
                        queue: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                    },
                    7 => Method::QueuePurgeOk {
                        message_count: RandomMethod::random(rng),
                    },
                    8 => Method::QueueDelete {
                        reserved_1: RandomMethod::random(rng),
                        queue: RandomMethod::random(rng),
                        if_unused: RandomMethod::random(rng),
                        if_empty: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                    },
                    9 => Method::QueueDeleteOk {
                        message_count: RandomMethod::random(rng),
                    },
                    _ => unreachable!(),
                },
                4 => match rng.gen_range(0u32..17) {
                    0 => Method::BasicQos {
                        prefetch_size: RandomMethod::random(rng),
                        prefetch_count: RandomMethod::random(rng),
                        global: RandomMethod::random(rng),
                    },
                    1 => Method::BasicQosOk {},
                    2 => Method::BasicConsume {
                        reserved_1: RandomMethod::random(rng),
                        queue: RandomMethod::random(rng),
                        consumer_tag: RandomMethod::random(rng),
                        no_local: RandomMethod::random(rng),
                        no_ack: RandomMethod::random(rng),
                        exclusive: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                        arguments: RandomMethod::random(rng),
                    },
                    3 => Method::BasicConsumeOk {
                        consumer_tag: RandomMethod::random(rng),
                    },
                    4 => Method::BasicCancel {
                        consumer_tag: RandomMethod::random(rng),
                        no_wait: RandomMethod::random(rng),
                    },
                    5 => Method::BasicCancelOk {
                        consumer_tag: RandomMethod::random(rng),
                    },
                    6 => Method::BasicPublish {
                        reserved_1: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        routing_key: RandomMethod::random(rng),
                        mandatory: RandomMethod::random(rng),
                        immediate: RandomMethod::random(rng),
                    },
                    7 => Method::BasicReturn {
                        reply_code: RandomMethod::random(rng),
                        reply_text: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        routing_key: RandomMethod::random(rng),
                    },
                    8 => Method::BasicDeliver {
                        consumer_tag: RandomMethod::random(rng),
                        delivery_tag: RandomMethod::random(rng),
                        redelivered: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        routing_key: RandomMethod::random(rng),
                    },
                    9 => Method::BasicGet {
                        reserved_1: RandomMethod::random(rng),
                        queue: RandomMethod::random(rng),
                        no_ack: RandomMethod::random(rng),
                    },
                    10 => Method::BasicGetOk {
                        delivery_tag: RandomMethod::random(rng),
                        redelivered: RandomMethod::random(rng),
                        exchange: RandomMethod::random(rng),
                        routing_key: RandomMethod::random(rng),
                        message_count: RandomMethod::random(rng),
                    },
                    11 => Method::BasicGetEmpty {
                        reserved_1: RandomMethod::random(rng),
                    },
                    12 => Method::BasicAck {
                        delivery_tag: RandomMethod::random(rng),
                        multiple: RandomMethod::random(rng),
                    },
                    13 => Method::BasicReject {
                        delivery_tag: RandomMethod::random(rng),
                        requeue: RandomMethod::random(rng),
                    },
                    14 => Method::BasicRecoverAsync {
                        requeue: RandomMethod::random(rng),
                    },
                    15 => Method::BasicRecover {
                        requeue: RandomMethod::random(rng),
                    },
                    16 => Method::BasicRecoverOk {},
                    _ => unreachable!(),
                },
                5 => match rng.gen_range(0u32..6) {
                    0 => Method::TxSelect {},
                    1 => Method::TxSelectOk {},
                    2 => Method::TxCommit {},
                    3 => Method::TxCommitOk {},
                    4 => Method::TxRollback {},
                    5 => Method::TxRollbackOk {},
                    _ => unreachable!(),
                },
                _ => unreachable!(),
            }
        }
    }
}
